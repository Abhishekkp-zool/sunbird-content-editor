/* Simple JavaScript Inheritance
 * By John Resig http://ejohn.org/
 * MIT Licensed.
 */
// Inspired by base2 and Prototype
(function() {
    var initializing = false,
        fnTest = /xyz/.test(function() {
            xyz;
        }) ? /\b_super\b/ : /.*/;

    // The base Class implementation (does nothing)
    this.Class = function() {};

    // Create a new Class that inherits from this class
    Class.extend = function(prop) {
        var _super = this.prototype;

        // Instantiate a base class (but only create the instance,
        // don't run the init constructor)
        initializing = true;
        var prototype = new this();
        initializing = false;

        // Copy the properties over onto the new prototype
        for (var name in prop) {
            // Check if we're overwriting an existing function
            prototype[name] = typeof prop[name] == "function" &&
                typeof _super[name] == "function" && fnTest.test(prop[name]) ?
                (function(name, fn) {
                    return function() {
                        var tmp = this._super;

                        // Add a new ._super() method that is the same method
                        // but on the super-class
                        this._super = _super[name];

                        // The method only need to be bound temporarily, so we
                        // remove it when we're done executing
                        var ret = fn.apply(this, arguments);
                        this._super = tmp;

                        return ret;
                    };
                })(name, prop[name]) :
                prop[name];
        }

        // The dummy class constructor
        function Class() {
            // All construction is actually done in the init method
            if (!initializing && this.init)
                this.init.apply(this, arguments);
        }

        // Populate our constructed prototype object
        Class.prototype = prototype;

        // Enforce the constructor to be what we expect
        Class.prototype.constructor = Class;

        // And make this class extendable
        Class.extend = arguments.callee;

        return Class;
    };
})();

/**
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */
window.fabric.Object.prototype.toObject = (function(toObject) {
    return function() {
        return window.fabric.util.object.extend(toObject.call(this), {
            meta: this.meta
        });
    };
})(window.fabric.Object.prototype.toObject);

var ekstep_editor = function() {};
ekstep_editor.prototype.jQuery = window.$;
ekstep_editor.prototype._ = window._;
var editor = new ekstep_editor();
window.EkstepEditor = editor;

window.ServiceConstants = {
    SEARCH_SERVICE: "search",
    POPUP_SERVICE: "popup",
    CONTENT_SERVICE: "content",
    ASSESSMENT_SERVICE: "assessment",
    LANGUAGE_SERVICE: "language",
    META_SERVICE: "meta",
    ASSET_SERVICE: "asset",
    TELEMETRY_SERVICE: "telemetry"
}

window.ManagerConstants = {
    EVENT_MANAGER: "event",
    MEDIA_MANAGER: "media",
    PLUGIN_MANAGER: "plugin",
    RESOURCE_MANAGER: "resource",
    STAGE_MANAGER: "stage",
    TOOLBAR_MANAGER: "toolbar"
}

EkstepEditor.init = function(context, config, $scope, $document, callback) {
    EkstepEditorAPI.globalContext = context; // TODO: Deprecate after the April release
    EkstepEditor.globalContext = context;
    EkstepEditor.toolbarManager.setScope($scope);
    EkstepEditor.keyboardManager.initialize($document);
    EkstepEditor._mergeConfig(config);
    EkstepEditor._loadDefaultPlugins(context, callback);
}

EkstepEditor._mergeConfig = function(config) {
    config = config || {};
    EkstepEditor.config = Object.assign(config, EkstepEditor.config);
}

EkstepEditor._loadDefaultPlugins = function(context, callback) {
    var startTime = (new Date()).getTime();
    if(EkstepEditor.config.corePluginsPackaged === true) EkstepEditor.jQuery("body").append($("<script type='text/javascript' src='scripts/coreplugins.js?" + EkstepEditor.config.build_number + "'>"));
    EkstepEditor.pluginManager.loadAllPlugins(EkstepEditor.config.plugins, function () {
        EkstepEditor.telemetryService.initialize({
            uid: context.uid,
            sid: context.sid,
            content_id: context.contentId
        }, EkstepEditor.config.dispatcher);
        callback();
        EkstepEditor.telemetryService.startEvent().append("loadtimes", { plugins: ((new Date()).getTime() - startTime) });
    });
}

EkstepEditor.loadBaseConfigManifest = function (cb) {
    EkstepEditor.resourceManager.loadResource(EkstepEditor.config.baseConfigManifest, 'json', function(err, data) {
        EkstepEditor.baseConfigManifest = [];
        if (err) {
            console.log('Unable to load baseConfigManifest');
        } else {
            EkstepEditor.baseConfigManifest = data;
        }
        cb(EkstepEditor.baseConfigManifest)
    });
}
EkstepEditor.config = {
    baseURL: 'https://dev.ekstep.in',
    apislug: '/api',
    defaultSettings: 'config/editorSettings.json',
    build_number: 'BUILDNUMBER',
    pluginRepo: '/plugins',
    aws_s3_urls: ["https://s3.ap-south-1.amazonaws.com/ekstep-public-dev/", "https://ekstep-public-dev.s3-ap-south-1.amazonaws.com/"],
    corePlugins: ["text", "audio", "div", "hotspot", "image", "shape", "scribble", "htext"],
    corePluginMapping: {
        "text": "org.ekstep.text", 
        "image": "org.ekstep.image", 
        "shape": "org.ekstep.shape",
        "stage": "org.ekstep.stage",
        "hotspot": "org.ekstep.hotspot",
        "scribble": "org.ekstep.scribblepad",
        "htext": "org.ekstep.text",
        "audio": "org.ekstep.audio"
    },
    baseConfigManifest: "config/baseConfigManifest.json",
    plugins: {
        "org.ekstep.developer":"1.0",
    },
    corePluginsPackaged: true,
    dispatcher: "local",
    useProxyForURL: true
}
/**
 * The base plugin class that all editor plugins inherit from. It provides the common support contract for all plugins.
 * Plugins can override specific methods to change the behavior. The most common scenario would be to override the
 * implementation of fabric callback methods to detect interactivity on the canvas.
 *
 * @class EkstepEditor.BasePlugin
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */
EkstepEditor.basePlugin = Class.extend({
    id: undefined,
    parent: undefined,
    children: [],
    manifest: undefined,
    editorObj: undefined,
    editorData: undefined,
    data: undefined,
    attributes: { x: 0, y: 0, w: 0, h: 0, visible: true, editable: true },
    config: undefined,
    event: undefined,
    events: undefined,
    params: undefined,
    media: undefined,
    configManifest: undefined,

    /**
     * Initializes the plugin with the given manifest and parent object
     * @param manifest {object} Manifest details for this plugin
     * @param data {object} Init parameters for the plugin
     * @param parent {object} Parent plugin object that instantiated this
     * @constructor
     * @memberof EkstepEditor.BasePlugin
     */
    init: function(manifest, data, parent) {
      var instance = this;
        this.manifest = _.cloneDeep(manifest);
        if (arguments.length == 1) {
            this.registerMenu();
            this.initialize();
            EkstepEditorAPI.addEventListener(this.manifest.id + ":create", this.create, this);
            console.log(manifest.id + " plugin initialized");
        } else {
            this.editorObj = undefined, this.event = undefined, this.attributes = { x: 0, y: 0, w: 0, h: 0, visible: true }, this.params = undefined, this.data = undefined, this.media = undefined;
            this.editorData = data;
            this.children = [];
            this.id = this.editorData.id || UUID();
            this.parent = parent;
            this.config = { opacity: 100, strokeWidth: 1, stroke: "rgba(255, 255, 255, 0)", autoplay: false, visible: true };
        }
        if (!EkstepEditor.baseConfigManifest) {
            EkstepEditor.loadBaseConfigManifest(function() {
                instance.configManifest = _.clone(EkstepEditor.baseConfigManifest, true);
            })
        } else {
            this.configManifest = _.clone(EkstepEditor.baseConfigManifest, true);
        }
    },

    /**
     * Initializes the plugin by reading from ECML.
     * @private
     * @memberof EkstepEditor.BasePlugin
     */
    initPlugin: function() {
        this.fromECML(this.editorData);
        this.newInstance();
        this.postInit();
    },

    /**
     * Post init tasks for the plugin
     * @private
     * @memberof EkstepEditor.BasePlugin
     */
    postInit: function() {
        this.registerFabricEvents();
        if (this.editorObj) { this.editorObj.set({ id: this.id }); this.editorObj.setVisible(true); }
        if(_.has(this.manifest.editor, 'behaviour')) {
            if(!_.isUndefined(this.manifest.editor.behaviour.rotatable) && (this.manifest.editor.behaviour.rotatable === true)) {
                if (this.editorObj) { this.editorObj.hasRotatingPoint = true; }
            }
        }
        if (this.parent) this.parent.addChild(this);
        if (this.parent && this.parent.type !== 'stage') EkstepEditorAPI.dispatchEvent('object:modified', { id: this.id });
    },

    /**
     * Registers the menu for this plugin. By default, the base plugin handles the menu additions.
     * Child implementations can use this method to override and register additional menu items.
     * @memberof EkstepEditor.BasePlugin
     */
    registerMenu: function() {
        var instance = this;
        this.manifest.editor.menu = this.manifest.editor.menu || [];
        _.forEach(this.manifest.editor.menu, function(menu) {
            menu.iconImage = menu.iconImage ? instance.relativeURL(menu.iconImage) : menu.iconImage;
            if (menu.submenu) {
                _.forEach(menu.submenu, function(dd) {
                    dd.iconImage = dd.iconImage ? instance.relativeURL(dd.iconImage) : dd.iconImage;
                });
            }
            if (menu.category === 'main') {
                EkstepEditor.toolbarManager.registerMenu(menu);
            } else if (menu.category === 'context') {
                EkstepEditor.toolbarManager.registerContextMenu(menu);
            } else if (menu.category === 'config') {
                EkstepEditor.toolbarManager.registerConfigMenu(menu);
            }
        });
    },

    /**
     * Returns relative URL for a particular asset. Plugins should use this method instead of
     * hard-coding the asset URLs.
     * @memberof EkstepEditor.BasePlugin
     */
    relativeURL: function(src) {
        return EkstepEditorAPI.resolvePluginResource(this.manifest.id, this.manifest.ver, src);
    },

    /**
     * Returns the type of this plugin (manifest ID)
     * @memberof EkstepEditor.BasePlugin
     */
    getType: function() {
        return this.manifest ? this.manifest.id : '';
    },

    /**
     * Returns the version of this plugin (manifest ID)
     * @memberof EkstepEditor.BasePlugin
     */
    getVersion: function() {
        return this.manifest ? this.manifest.ver : '';
    },

    /**
     * Registers listeners for Fabricjs events from the canvas. Child implementations should override
     * the actual callback methods instead of overriding this one.
     * @private
     * @memberof EkstepEditor.BasePlugin
     */
    registerFabricEvents: function() {
        if (this.editorObj) {
            this.editorObj.on({
                added: function(options, event) {
                    var inst = EkstepEditorAPI.getPluginInstance(this.id);
                    inst.added(inst, options, event);
                    if (inst.editorObj) {
                        EkstepEditorAPI.updatePluginDimensions(inst);
                    }
                },
                removed: function(options, event) {
                    var inst = EkstepEditorAPI.getPluginInstance(this.id);
                    inst.removed(inst, options, event);
                    _.forEach(inst.children, function(child, index) {
                        child.editorObj.remove();
                    });
                    inst.remove();
                },
                selected: function(options, event) {
                    var inst = EkstepEditorAPI.getPluginInstance(this.id);
                    inst.selected(inst, options, event)
                },
                deselected: function(options, event) {
                    var inst = EkstepEditorAPI.getPluginInstance(this.id);
                    inst.deselected(inst, options, event)
                },
                modified: function(options, event) {
                    var inst = EkstepEditorAPI.getPluginInstance(this.id);
                    if (inst.editorObj) {
                        EkstepEditorAPI.updatePluginDimensions(inst);
                    }
                    inst.changed(inst, options, event)
                },
                rotating: function(options, event) {
                    var inst = EkstepEditorAPI.getPluginInstance(this.id);
                    inst.rotating(inst, options, event)
                },
                scaling: function(options, event) {
                    var inst = EkstepEditorAPI.getPluginInstance(this.id);
                    inst.scaling(inst, options, event);
                },
                moving: function(options, event) {
                    var inst = EkstepEditorAPI.getPluginInstance(this.id);
                    inst.moving(inst, options, event)
                },
                skewing: function(options, event) {
                    var inst = EkstepEditorAPI.getPluginInstance(this.id);
                    inst.skewing(inst, options, event)
                }
            });
        }
    },

    /**
     * Helper method to load a given resource relative to the plugin.
     * @memberof EkstepEditor.BasePlugin
     */
    loadResource: function(src, dataType, cb) {
        EkstepEditorAPI.loadPluginResource(this.manifest.id, this.manifest.ver, src, dataType, cb);
    },

    /**
     * Removes the plugin from the stage. This can be used to perform self cleanup. If this method is called
     * from newInstance(), plugin won't be added to stage children.
     * @memberof EkstepEditor.BasePlugin
     */
    remove: function() {
        if (this.parent) {
            this.parent.removeChild(this);
            this.parent =  undefined; // if this method is called from newInstance(), plugin won't be added to stage children    
        }
        delete EkstepEditor.pluginManager.pluginInstances[this.id];
    },

    /**
     * Creates the instance of the plugin when a new object is added to the canvas.
     * @private
     * @memberof EkstepEditor.BasePlugin
     */
    create: function(event, data) {
        EkstepEditorAPI.instantiatePlugin(this.manifest.id, _.clone(data), EkstepEditor.stageManager.currentStage);
    },

    /**
     * Adds a child to this object. This can be useful for composite scenarios.
     * @memberof EkstepEditor.BasePlugin
     */
    addChild: function(plugin) {
        this.children.push(plugin);
    },

    /**
     * Removes a child from this plugin. Use this to dynamically manage composite children.
     * @memberof EkstepEditor.BasePlugin
     */
    removeChild: function(plugin) {
        this.children = _.reject(this.children, { id: plugin.id });
    },

    /**
     * Initialize the plugin when it is loaded. This is a no-op implementation and child classes must
     * provide the complete functional implementation.
     * @memberof EkstepEditor.BasePlugin
     */
    initialize: function(data) {},

    /**
     * Instantiate an object of the plugin type. This is a no-op implementation and child classes must
     * provide the complete functional implementation.
     * @memberof EkstepEditor.BasePlugin
     */
    newInstance: function(data) {},

    /**
     * Called when the plugin is added to the canvas. This is a no-op implementation and child classes must
     * provide the complete functional implementation.
     * @memberof EkstepEditor.BasePlugin
     */
    added: function(instance, options, event) {},

    /**
     * Called when the plugin is removed from the canvas. This is a no-op implementation and child classes must
     * provide the complete functional implementation.
     * @memberof EkstepEditor.BasePlugin
     */
    removed: function(instance, options, event) {},

    /**
     * Called when the object is selected on the canvas. This is a no-op implementation and child classes must
     * provide the complete functional implementation.
     * @memberof EkstepEditor.BasePlugin
     */
    selected: function(instance, options, event) {},

    /**
     * Called when the object loses focus on the canvas. This is a no-op implementation and child classes must
     * provide the complete functional implementation.
     * @memberof EkstepEditor.BasePlugin
     */
    deselected: function(instance, options, event) {},

    /**
     * Called when the object is modified (dragged, resized or rotated). This is a no-op implementation and child classes must
     * provide the complete functional implementation.
     * @memberof EkstepEditor.BasePlugin
     */
    changed: function(instance, options, event) {},

    /**
     * Called continuously while the object is rotating. This is a no-op implementation and child classes must
     * provide the complete functional implementation.
     * @memberof EkstepEditor.BasePlugin
     */
    rotating: function(instance, options, event) {},

    /**
     * Called continuously while the object is scaling. This is a no-op implementation and child classes must
     * provide the complete functional implementation.
     * @memberof EkstepEditor.BasePlugin
     */
    scaling: function(instance, options, event) {},

    /**
     * Called continuously while the object is being dragged. This is a no-op implementation and child classes must
     * provide the complete functional implementation.
     * @memberof EkstepEditor.BasePlugin
     */
    moving: function(instance, options, event) {},

    /**
     * Called continuously while the object is being skewed. This is a no-op implementation and child classes must
     * provide the complete functional implementation.
     * @memberof EkstepEditor.BasePlugin
     */
    skewing: function(instance, options, event) {},

    /**
     * Allows plugins to create a copy of the object. Default implementation just creates a clone. Child
     * classes can override the logic to customize how copy is done.
     * @memberof EkstepEditor.BasePlugin
     */
    doCopy: function() {
        return this.editorObj;
    },

    /**
     * Returns a copy of the object by converting it to ECML markup.
     * @private
     * @memberof EkstepEditor.BasePlugin
     */
    getCopy: function() {
        return this.toECML();
    },

    /**
     * Renders the plugin to canvas. Default implementation adds the editor fabric object to canvas.
     * Complex plugins and templates should override this if necessary.
     * @memberof EkstepEditor.BasePlugin
     */
    render: function(canvas) {
        canvas.add(this.editorObj);
    },

    /**
     * Returns the metadata of the object. This is a no-op implementation. Child plugins should override
     * this method to return custom metadata.
     * @memberof EkstepEditor.BasePlugin
     */
    getMeta: function() { },

    /**
     * Utility method to convert canvas pixels to relative units. By design, all rendering must work with
     * relative units to allow content to be rendered on different types of devices with different pixel
     * ratios and density. Plugins must always use the relative units for rendering.
     * @memberof EkstepEditor.BasePlugin
     */
    pixelToPercent: function(obj) {
        obj.x = parseFloat(((obj.x / 720) * 100).toFixed(2));
        obj.y = parseFloat(((obj.y / 405) * 100).toFixed(2));
        obj.w = parseFloat(((obj.w / 720) * 100).toFixed(2));
        obj.h = parseFloat(((obj.h / 405) * 100).toFixed(2));
        obj.rotate = parseFloat(obj.rotate);
    },

    /**
     * Utility method to convert relative units to pixels on canvas. By design, all rendering must work with
     * relative units to allow content to be rendered on different types of devices with different pixel
     * ratios and density. Plugins must always use the relative units for rendering.
     * @memberof EkstepEditor.BasePlugin
     */
    percentToPixel: function(obj) {
        obj.x = obj.x * (720 / 100);
        obj.y = obj.y * (405 / 100);
        obj.w = obj.w * (720 / 100);
        obj.h = obj.h * (405 / 100);
        obj.rotate = obj.rotate;
    },

    /**
     * Sets the config for this object. Override this method to parse the config if necessary.
     * @memberof EkstepEditor.BasePlugin
     */
    setConfig: function(data) {
        this.config = data;
    },

    /**
     * Adds a given config key and value pair to the config for this plugin instance.
     * @memberof EkstepEditor.BasePlugin
     */
    addConfig: function(key, value) {
        if (_.isUndefined(this.config)) this.config = {};
        this.config[key] = value;
    },

    /**
     * Returns the config for this plugin. Child plugins should override this method to generate the
     * custom plugin JSON objects.
     * @memberof EkstepEditor.BasePlugin
     */
    getConfig: function() {
        return this.config;
    },

    /**
     * Returns the data that this plugin might set and use at runtime. As a best practice, plugins should
     * differentiate between config (e.g. rendering colors, font size, levels etc) and data (actual
     * word details to use).
     * @memberof EkstepEditor.BasePlugin
     */
    setData: function(data) {
        this.data = data;
    },

    /**
     * Returns the data for this plugin. Data includes actual drivers - such as the words in a word game
     * or questions in a quiz. Plugins should set their data is they want to differentiate from
     * the config.
     * @memberof EkstepEditor.BasePlugin
     */
    getData: function() {
        return this.data;
    },

    /**
     * Manages the ECML attributes for the plugins. This includes x,y,w,h and rotation related attributes
     * that are common to all plugins.
     * @private
     * @memberof EkstepEditor.BasePlugin
     */
    setAttributes: function(attr) {
        _.merge(this.attributes, attr);
    },

    /**
     * Returns the ECML attributes for the plugins. This includes x,y,w,h and rotation related attributes
     * that are common to all plugins.
     * @private
     * @memberof EkstepEditor.BasePlugin
     */
    getAttributes: function() {
        return _.omit(this.attributes, ['top', 'left', 'width', 'height']);
    },

    /**
     * Modigies the ECML attributes for the plugins. This includes x,y,w,h and rotation related attributes
     * that are common to all plugins.
     * @private
     * @memberof EkstepEditor.BasePlugin
     */
    setAttribute: function(key, value) {
        this.attributes[key] = value;
    },

    /**
     * Returns the individual ECML attribute for the plugins. This includes x,y,w,h and rotation related attributes
     * that are common to all plugins.
     * @param key {string} Attribute name
     * @private
     * @memberof EkstepEditor.BasePlugin
     */
    getAttribute: function(key) {
        return this.attributes[key];
    },

    /**
     * Adds a runtime event listener for this plugin. Plugins can respond to events on the renderer
     * such as stage entry, exit or results of evaluation.
     * @param event {object} Event object
     * @private
     * @memberof EkstepEditor.BasePlugin
     */
    addEvent: function(event) {
        if (_.isUndefined(this.event)) this.event = [];
        this.event.push(event);
    },

    /**
     * Returns the list of runtime events configured for this plugin. Plugins can respond to events on the renderer
     * such as stage entry, exit or results of evaluation.
     * @param event {object} Event object
     * @memberof EkstepEditor.BasePlugin
     */
    getEvents: function() {
        return this.event;
    },

    /**
     * Adds a runtime param - such as teacher instructions to the ECML output. Params are like shared variables
     * that can be used for evaluation across stages on the renderer.
     * @param key {string} Name of the runtime parameter
     * @param value {object} Data of the parameter
     * @memberof EkstepEditor.BasePlugin
     */
    addParam: function(key, value) {
        if (_.isUndefined(this.params)) this.params = {};
        this.params[key] = value;
    },

    /**
     * Removes a runtime param for this plugin.
     * @param key {string} Name of the param to remove.
     * @memberof EkstepEditor.BasePlugin
     */
    deleteParam: function(key){
        if(this.params) delete this.params[key];
    },

    /**
     * Returns the list of runtime params for this plugin.
     * @memberof EkstepEditor.BasePlugin
     */
    getParams: function() {
        return this.params;
    },

    /**
     * Returns the specified runtime parameter details. Note that the value of the parameter
     * is only available at runtime.
     * @param key {string} Name of the param to return.
     * @memberof EkstepEditor.BasePlugin
     */
    getParam: function(key) {
        return this.params ? this.params[key] : undefined;
    },

    /**
     * Adds media to the manifest of this plugin. You can add media such as images, audios, or even
     * other runtime dependencies such as JS, CSS and other plugin files. If you don't declare a
     * media, it will not be included in the content download archive.
     * @param media {object} Media to be included at runtime.
     * @memberof EkstepEditor.BasePlugin
     */
    addMedia: function(media) {
        if (_.isUndefined(this.media)) this.media = {};
        this.media[media.id] = media;
    },

    /**
     * Returns the media manifest of this plugin. You can add media such as images, audios, or even
     * other runtime dependencies such as JS, CSS and other plugin files. If you don't declare a
     * media, it will not be included in the content download archive.
     * @param media {object} Media to be included at runtime.
     * @memberof EkstepEditor.BasePlugin
     */
    getMedia: function() {
        return this.media;
    },

    /**
     * Returns the renderer dimensions for this plugin. This includes the x,y,w,h bounding box,
     * and the rotation of the object.
     * @memberof EkstepEditor.BasePlugin
     */
    getRendererDimensions: function() {
        var attr = this.getAttributes();
        var dims = {
            x: attr.x,
            y: attr.y,
            w: attr.w,
            h: attr.h,
            rotate: attr.rotate
        }
        this.pixelToPercent(dims);
        return dims;
    },

    /**
     * Generates and returns the ECML string for this plugin.
     * @private
     * @memberof EkstepEditor.BasePlugin
     */
    toECML: function() {
        if(this.editorObj) EkstepEditorAPI.updatePluginDimensions(this);
        var attr = _.clone(this.getAttributes());
        attr.id = this.id;
        this.pixelToPercent(attr);
        if (!_.isUndefined(this.getData())) {
            attr.data = {
                "__cdata": JSON.stringify(this.getData())
            };
        }
        if (!_.isUndefined(this.getConfig())) {
            attr.config = {
                "__cdata": JSON.stringify(this.getConfig())
            };
        }
        if (!_.isUndefined(this.getEvents())) {
            // attr.config = {
            //     "__cdata": JSON.stringify(this.getEvents())
            // };
            attr.event = this.getEvents();
        }
        if (!_.isUndefined(this.getParams())) {
            attr.param = [];
            _.forIn(this.getParams(), function(value, key) {
                attr.param.push({ name: key, value: value });
            });
        }
        return attr;
    },

    /**
     * Parses the ECML to construct this object.
     * @private
     * @param data {object} ECML to recontruct from
     * @memberof EkstepEditor.BasePlugin
     */
    fromECML: function(data) {
        var instance = this;
        this.attributes = data;
        if (!_.isUndefined(this.attributes.data)) {
            this.data = this.attributes.data.__cdata ? JSON.parse(this.attributes.data.__cdata) : this.attributes.data;
            delete this.attributes.data;
        }
        if (!_.isUndefined(this.attributes.config)) {
            this.config = this.attributes.config.__cdata ? JSON.parse(this.attributes.config.__cdata) : this.attributes.config;
            delete this.attributes.config;
        }
        if (!_.isUndefined(this.attributes.events)) {
            //this.events = JSON.parse(this.attributes.event.__cdata);
            delete this.attributes.events;
        }
        if (!_.isUndefined(this.attributes.event)) {
            //this.events = JSON.parse(this.attributes.event.__cdata);
            this.event = this.attributes.event;
            delete this.attributes.event;
        }
        if (!_.isUndefined(this.attributes.param)) {
            _.forEach(this.attributes.param, function(param) {
                instance.addParam(param.name, param.value);
            })
            delete this.attributes.param;
        }
        if (!_.isUndefined(this.attributes.asset)) {
            if (!_.isUndefined(this.attributes.assetMedia)) {
                instance.addMedia(this.attributes.assetMedia);
                delete this.attributes.assetMedia;
            } else {
                var media = EkstepEditor.mediaManager.getMedia(this.attributes.asset);
                if (!_.isUndefined(media)) {
                    instance.addMedia(media);
                }
            }
        }
        this.percentToPixel(this.attributes);
    },

    /**
     * Utility function to conver the data of the object to Fabric properties - a simple variable
     * transformation that returns the corresponding fabric parameter names.
     * @param data {object} Data of the current plugin instance.
     * @memberof EkstepEditor.BasePlugin
     */
    convertToFabric: function(data) {
        var retData = _.clone(data);
        if (data.x) retData.left = data.x;
        if (data.y) retData.top = data.y;
        if (data.w) retData.width = data.w;
        if (data.h) retData.height = data.h;
        if (data.radius) retData.rx = data.radius;
        if (data.color) retData.fill = data.color;
        if (data.rotate) retData.angle = data.rotate;
        return retData;
    },
    getConfigManifest: function() {
        if (!this.manifest.editor.configManifest) { this.manifest.editor.configManifest = []; }
        var configManifest = this.manifest.editor.configManifest
        if (this.configManifest) {
            configManifest = _.uniqBy(_.clone(_.concat(this.manifest.editor.configManifest, this.configManifest),true),'propertyName');
        }
        if (!(this.manifest.editor.playable && this.manifest.editor.playable === true)) {
          _.remove(configManifest, function (cm) {return cm.propertyName === 'autoplay'})
        }
        return configManifest
    },

    /**
     * Allows a plugin to update the context menu when the plugin instance is selected. Plugins can use
     * this method to change any specific custom context menu actions.
     * @memberof EkstepEditor.BasePlugin
     */
    updateContextMenu: function() {

    },

    /**
     * Plugins can override this to reset their configuration.
     * @memberof EkstepEditor.BasePlugin
     */
    reConfig: function() {
    },

    /**
     * Called when the configuration is modified for the plugin. This is useful if the plugin
     * has to provide WYSIWYG feedback on the fabric canvas.
     * @param key {string} Config property name
     * @param value {string} Value of the config setting.
     * @memberof EkstepEditor.BasePlugin
     */
    _onConfigChange: function(key, value) {
        this.addConfig(key, value);
        var currentInstace = EkstepEditorAPI.getCurrentObject();
        if (currentInstace) {
            if (currentInstace.config === undefined) { currentInstace.config = {} }
            switch (key) {
                case 'opacity':
                    currentInstace.editorObj.setOpacity(value/100);
                    currentInstace.attributes.opacity = value/100;
                    currentInstace.config.opacity = value;
                    break;
                case 'strokeWidth':
                    value = parseInt(value);
                    currentInstace.editorObj.set('strokeWidth', value);
                    currentInstace.attributes['stroke-width'] = value;
                    currentInstace.attributes['strokeWidth'] = value;
                    currentInstace.config.strokeWidth = value;
                    break;
                case 'stroke':
                    currentInstace.editorObj.setStroke(value);
                    currentInstace.attributes.stroke = value;
                    currentInstace.config.stroke = value;
                    break;
                case 'autoplay':
                    currentInstace.attributes.autoplay = value;
                    currentInstace.config.autoplay = value;
                    break;
                case 'visible':
                    currentInstace.attributes.visible = value;
                    currentInstace.config.visible = value;
                    break;
            }
            EkstepEditorAPI.render();
            EkstepEditorAPI.dispatchEvent('object:modified', { target: EkstepEditorAPI.getEditorObject() });
        }
    },

    /**
     * Returns the help text for this plugin by reading the help markdown file. Plugins can override this
     * to return custom help.
     * @memberof EkstepEditor.BasePlugin
     */
    getHelp: function(cb) {
        var helpText = "Help is not available."
        try {
            this.loadResource(this.manifest.editor.help.src, this.manifest.editor.help.dataType, function(err, help) {
                if (!err) {
                    helpText = help;
                    cb(helpText);
                }
            });
        } catch (e) {
            console.log(e)
            cb(helpText);
        }
    },

    /**
     * Returns the properties that editable for this plugin instance.
     * @private
     * @memberof EkstepEditor.BasePlugin
     */
    getProperties: function() {
        var props = _.omitBy(_.clone(this.attributes), _.isObject);
        props = _.omitBy(props, _.isNaN);
        this.pixelToPercent(props);
        return props;
    },

    /**
     * Renders the configuration view for this plugin. Default functionality is to launch the config
     * property editor. Plugins can override this method to change the way config is rendered.
     * @memberof EkstepEditor.BasePlugin
     */
    renderConfig: function() {

    },

    /**
     * Returns the manifest ID of this object
     * @memberof EkstepEditor.BasePlugin
     */
    getManifestId: function () {
      return (this.manifest.shortId || this.manifest.id);
    }
});

/**
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */
EkstepEditor.eventManager = new (Class.extend({
	enableEvents: true,
	addEventListener: function(type, callback, scope) {
		EventBus.addEventListener(type, callback, scope)
	},
	dispatchEvent: function(type, data, target) {
		if(this.enableEvents) EventBus.dispatch(type, target, data);
	},
	removeEventListener: function(type, callback, scope) {
		EventBus.removeEventListener(type, callback, scope);
	}
}));
/**
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */
EkstepEditor.pluginManager = new(Class.extend({
    plugins: {},
    pluginObjs: {},
    pluginInstances: {},
    errors: [],
    init: function() {
        console.log("Plugin manager initialized");
    },
    registerPlugin: function(manifest, plugin, repo) {
        repo = repo || EkstepEditor.publishedRepo;
        this.plugins[manifest.id] = { p: plugin, m: manifest, 'repo': repo };
        var p = new plugin(manifest); // Initialize plugin
        this.pluginObjs[manifest.id] = p;
        EkstepEditorAPI.dispatchEvent('plugin:load', { plugin: manifest.id, version: manifest.ver });
        EkstepEditorAPI.dispatchEvent(manifest.id + ':load');
    },
    loadAndInitPlugin: function(pluginId, version, publishedTime) {
        this.loadPlugin(pluginId, version, publishedTime);
        if(this.isDefined(pluginId)) {
            var pluginManifest = this.getPluginManifest(pluginId);
            if (pluginManifest.type && EkstepEditorAPI._.lowerCase(pluginManifest.type) === "widget") {
                this.invoke(pluginId, _.cloneDeep(pluginManifest.editor['init-data'] || {}), EkstepEditorAPI.getCurrentStage());    
            }
            return 0;
        } else {
            return 1;
        }
    },
    loadPlugin: function(pluginId, pluginVer, publishedTime) {
        var instance = this;
        if (this.plugins[pluginId]) {
            console.log('A plugin with id "' + pluginId + '" and ver "' + pluginVer + '" is already loaded');
        } else {
            EkstepEditor.resourceManager.discoverManifest(pluginId, pluginVer, function(err, data) {
                if (err || _.isUndefined(data)) {
                    console.error('Unable to load plugin manifest', 'plugin:' + pluginId + '-' + pluginVer, 'Error:', err);
                } else {
                    instance.loadDependencies(data.manifest, data.repo, publishedTime);
                    instance.loadPluginByManifest(data.manifest, data.repo, publishedTime);
                }
            }, publishedTime);
        }
    },
    loadPluginByManifest: function(manifest, repo, publishedTime) {
        var instance = this;
        EkstepEditor.resourceManager.getResource(manifest.id, manifest.ver, manifest.editor.main, 'text', repo, function(err, data) {
            if (err) {
                console.error('Unable to load editor plugin', 'plugin:' + manifest.id + '-' + manifest.ver, 'resource:' + manifest.editor.main, 'Error:', err);
            } else {
                try {
                    instance.registerPlugin(manifest, eval(data), repo);
                    EkstepEditorAPI.dispatchEvent('plugin:load', { plugin: manifest.id, version: manifest.ver });
                } catch (e) {
                    console.error("Error while loading plugin", 'plugin:' + manifest.id + '-' + manifest.ver, 'Error:', e);
                }
            }
        }, publishedTime);
    },
    loadDependencies: function(manifest, repo, publishedTime) {
        var instance = this;
        if (_.isArray(manifest.editor.dependencies)) {
            _.forEach(manifest.editor.dependencies, function(dependency) {
                if (dependency.type == 'plugin') {
                    instance.loadPlugin(dependency.plugin, dependency.ver, publishedTime);
                } else {
                    EkstepEditor.resourceManager.loadExternalResource(dependency.type, manifest.id, manifest.ver, dependency.src, repo, publishedTime);
                }
            });
        }
    },
    isDefined: function(id) {
        if (this.plugins[id]) {
            return true;
        } else {
            return false;
        }
    },
    invoke: function(id, data, parent, override) {
        var instance = this;
        var p = undefined;
        var plugin = this.plugins[id];
        if (!plugin) {
            this.addError('No plugin found for - ' + id);
        } else {
            var pluginClass = override ? plugin.p.extend(override) : plugin.p;
            var pluginManifest = plugin.m;
            try {
                if (_.isArray(data)) {
                    data.forEach(function(d) {
                        p = new pluginClass(pluginManifest, d, parent);
                        instance.addPluginInstance(p);
                        p.initPlugin();
                        EkstepEditorAPI.dispatchEvent('plugin:add', { plugin: pluginManifest.id, version: pluginManifest.ver, instanceId: p.id });
                        EkstepEditorAPI.dispatchEvent(pluginManifest.id + ':add');
                    })
                } else {
                    p = new pluginClass(pluginManifest, data, parent);
                    instance.addPluginInstance(p);
                    p.initPlugin();
                    EkstepEditorAPI.dispatchEvent('plugin:add', { plugin: pluginManifest.id, version: pluginManifest.ver, instanceId: p.id });
                    EkstepEditorAPI.dispatchEvent(pluginManifest.id + ':add');                    
                }
            } catch(e) {
                throw new Error(e);
            }
        }
        return p;
    },
    addPluginInstance: function(pluginObj) {
        this.pluginInstances[pluginObj.id] = pluginObj;
    },
    removePluginInstance: function(pluginObj) {
        if (pluginObj) pluginObj.remove();
    },
    getPluginInstance: function(id) {
        return this.pluginInstances[id];
    },
    getPluginManifest: function(id) {
        var plugin = this.plugins[id];
        if (plugin) {
            return plugin.m;
        } else {
            return undefined;
        }
    },
    addError: function(error) {
        this.errors.push(error);
    },
    getErrors: function() {
        return this.errors;
    },
    cleanUp: function() {
        this.pluginInstances = {};
        this.plugins = {};
        this.errors = [];
    },
    getPlugins: function() {
        return Object.keys(this.plugins);
    },
    getPluginType: function(id) {
        if (this.pluginInstances[id]) {
            return this.pluginInstances[id].getType();
        } else {
            return '';
        }
    },
    loadAllPlugins: function(plugins, callback) {
        if (_.isEmpty(plugins)) {
            callback();
        }
        var instance = this;
        var q = async.queue(function(plugin, pluginCallback) {
            instance.loadPlugin(plugin.key, plugin.value);
            pluginCallback();
        }, 6);
        q.drain = function() {
            callback();
        };
        _.forIn(plugins, function(value, key) {
            q.push({ "key": key, "value": value }, function(err) {});
        });
    },
    loadPluginResource: function(pluginId, pluginVer, src, dataType, callback) {
        if (this.plugins[pluginId]) {
            EkstepEditor.resourceManager.getResource(pluginId, pluginVer, src, dataType, this.plugins[pluginId]['repo'], callback)
        } else {
            callback(new Error("unable load plugin resource " + src), undefined)
        }
    },
    getPluginVersion: function(id) {
        if (this.pluginInstances[id]) {
            return this.pluginInstances[id].getVersion();
        } else {
            return '';

        }
    },
    resolvePluginResource: function (id, ver, resource) {
        if (this.plugins[id] && this.plugins[id]["repo"]) {
            return this.plugins[id]["repo"].resolveResource(id, ver, resource);
        } else{
            return false;
        }
    }
}));

/**
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */
EkstepEditor.stageManager = new(Class.extend({
    stages: [],
    thumbnails: {},
    currentStage: undefined,
    canvas: undefined,
    contentLoading: false,
    init: function() {
        var instance = this;
        fabric.Object.prototype.transparentCorners = false;
        fabric.Object.prototype.lockScalingFlip = true;
        fabric.Object.prototype.hasRotatingPoint = false;
        fabric.Object.prototype.cornerSize = 6;
        fabric.Object.prototype.padding = 2;
        fabric.Object.prototype.borderColor = "#1A98FA";
        fabric.Object.prototype.cornerColor = "#1A98FA";
        //fabric.Object.prototype.rotatingPointOffset = 18; //TODO need to add rotation in bas class
        this.canvas = new fabric.Canvas('canvas', { backgroundColor: '#FFFFFF', preserveObjectStacking: true, perPixelTargetFind: false });
        console.log("Stage manager initialized");
        EkstepEditor.eventManager.addEventListener("stage:delete", this.deleteConfirmationDialog, this);
        EkstepEditor.eventManager.addEventListener("stage:duplicate", this.duplicateStage, this);
    },
    clearCanvas: function(canvas) {
        canvas.clear();
        canvas.setBackgroundColor('#FFFFFF', canvas.renderAll.bind(canvas));
    },
    registerEvents: function() {
        var instance = this;        
        this.canvas.on("object:modified", function(options, event) {
            EkstepEditor.stageManager.dispatchObjectEvent('modified', options, event);
        });
        this.canvas.on("object:selected", function(options, event) {
            EkstepEditor.stageManager.dispatchObjectEvent('selected', options, event);
        });
        this.canvas.on("selection:cleared", function(options, event) {
            EkstepEditor.stageManager.dispatchObjectEvent('unselected', options, event);
        });
        this.canvas.on("object:added", function(options, event) {
            EkstepEditor.stageManager.dispatchObjectEvent('added', options, event);
        });
        this.canvas.on("object:removed", function(options, event) {
            EkstepEditor.stageManager.dispatchObjectEvent('removed', options, event);
        });
        this.canvas.on("object:moving", function(options, event) {
            EkstepEditor.stageManager.dispatchObjectEvent('moving', options, event);
        });
        this.canvas.on("object:scaling", function(options, event) {
            EkstepEditor.stageManager.dispatchObjectEvent('scaling', options, event);
        });
        EkstepEditor.eventManager.addEventListener("stage:select", this.selectStage, this);
    },
    dispatchObjectEvent: function(eventType, options, event) {
        var meta = EkstepEditor.stageManager.getObjectMeta(options);
        EkstepEditor.eventManager.dispatchEvent('object:' + eventType, meta);
        if (meta.type != '') {
            EkstepEditor.eventManager.dispatchEvent(meta.type + ':' + eventType, meta);
        }
    },
    selectStage: function(event, data) {
        if (_.isUndefined(this.currentStage)) {
            this.currentStage = _.find(this.stages, { id: data.stageId });
            this.currentStage.isSelected = true;
            this.currentStage.setCanvas(this.canvas);
            this.currentStage.render(this.canvas);
        } else {
            this.currentStage.isSelected = false;
            EkstepEditor.eventManager.dispatchEvent('stage:unselect', { stageId: this.currentStage.id });
            this.clearCanvas(this.canvas);
            this.currentStage = _.find(this.stages, { id: data.stageId });
            this.currentStage.isSelected = true;
            this.canvas.off("object:added");
            this.currentStage.setCanvas(this.canvas);
            this.currentStage.render(this.canvas);
            this.canvas.on("object:added", function(options, event) {
                EkstepEditor.stageManager.dispatchObjectEvent('added', options, event);
            });
        }
        EkstepEditorAPI.dispatchEvent('config:showSettingsTab', {id: this.currentStage.id});        
    },
    addStage: function(stage) {
        var prevStageId = _.isUndefined(this.currentStage) ? undefined : this.currentStage.id;
        this.addStageAt(stage, stage.attributes.position);
        this.selectStage(null, { stageId: stage.id });
        EkstepEditorAPI.dispatchEvent('stage:add', { stageId: stage.id, prevStageId: prevStageId });
    },
    deleteStage: function(event, data) {
        var currentStage = _.find(this.stages, { id: data.stageId });
        this.deleteStageInstances(currentStage);
        var currentStageIndex = this.getStageIndex(currentStage);
        this.stages.splice(currentStageIndex, 1);
        if (this.stages.length === 0) EkstepEditorAPI.dispatchEvent('stage:create', { "position": "next" });
        else if (currentStageIndex === this.stages.length) this.selectStage(null, { stageId: this.stages[currentStageIndex - 1].id });
        else this.selectStage(null, { stageId: this.stages[currentStageIndex].id });
        EkstepEditorAPI.dispatchEvent('stage:removed', { stageId: data.stageId});
    },
    deleteStageInstances: function(stage) {
        _.forEach(_.clone(stage.canvas.getObjects()), function(obj) {
            stage.canvas.remove(obj);
        });
    },
    getStageIndex: function(stage) {
        return EkstepEditorAPI.getAllStages().findIndex(function(obj) {
            return obj.id === stage.id
        });
    },
    getStage: function(stageId) {
        return _.find(this.stages, { id: stageId });
    },
    duplicateStage: function(event, data) {
        var currentStage = _.find(this.stages, { id: data.stageId }), instance = this, plugins = [];
        var stage = this.stages[this.getStageIndex(currentStage)];
        EkstepEditorAPI.dispatchEvent('stage:create', { "position": "afterCurrent" });        
        EkstepEditor.eventManager.enableEvents = false;
        _.forEach(stage.children, function(plugin) {
            plugins.push({'z-index': plugin.attributes['z-index'], data: plugin });
        });
        _.forEach(_.sortBy(plugins, 'z-index'), function(plugin) {            
            EkstepEditorAPI.cloneInstance(plugin.data);
        });
        this.currentStage.destroyOnLoad(stage.children.length, this.canvas, function(){
            EkstepEditor.eventManager.enableEvents = true;
        });
        EkstepEditorAPI.dispatchEvent('stage:select', { stageId: this.currentStage.id });      

    },
    getObjectMeta: function(options) {
        var pluginId = (options && options.target) ? options.target.id : '';
        return {
            'id': pluginId,
            'type': EkstepEditor.pluginManager.getPluginType(pluginId),
            'ver': EkstepEditor.pluginManager.getPluginVersion(pluginId)
        }
    },
    addStageAt: function(stage, position) {
        var currentIndex;
        switch (position) {
            case "beginning":
                this.stages.unshift(stage);
                break;
            case "end":
            case "next":
                this.stages.push(stage);
                break;
            case "afterCurrent":
            case "beforeCurrent":
                currentIndex = this.getStageIndex(EkstepEditorAPI.getCurrentStage());
                if (position === "afterCurrent" && currentIndex >= 0) this.stages.splice(currentIndex + 1, 0, stage);
                if (position === "beforeCurrent" && currentIndex >= 0) this.stages.splice(currentIndex, 0, stage);
                break;
            default:
                this.stages.push(stage)
                break;
        };
    },
    onStageDragDrop: function(srcStageId, destStageId) {
        var srcIdx = this.getStageIndexById(srcStageId);
        var destIdx = this.getStageIndexById(destStageId);
        if (srcIdx < destIdx) {
            var src = this.stages[srcIdx];
            for (var i = srcIdx; i <= destIdx; i++) {
                this.stages[i] = this.stages[i + 1];
                if (i === destIdx) this.stages[destIdx] = src;
            }
        }
        if (srcIdx > destIdx) {
            var src = this.stages[srcIdx];
            for (var i = srcIdx; i >= destIdx; i--) {
                this.stages[i] = this.stages[i - 1];
                if (i === destIdx) this.stages[destIdx] = src;
            }
        }

        EkstepEditorAPI.dispatchEvent('stage:reorder', { stageId: srcStageId, fromIndex: srcIdx, toIndex: destIdx });
    },
    getStageIndexById: function(stageId) {
        return _.findIndex(this.stages, function(stage) {
            return stage.id == stageId;
        });
    },
    deleteConfirmationDialog: function(event, data) {
        var instance = this;
        EkstepEditorAPI.getService('popup').open({
            template: 'deleteStageDialog.html',
            controller: ['$scope', function($scope) {
                $scope.delete = function() {
                    $scope.closeThisDialog();
                    instance.deleteStage(event, data);
                }
            }],
            showClose: false
        });
    },
    showLoadScreenMessage: function() {
        var obj = _.find(EkstepEditorAPI.getAngularScope().appLoadMessage, { 'id': 3});
        if (_.isObject(obj)) {
            obj.message = "Loading your lesson";
            obj.status = true;
        }
        EkstepEditorAPI.ngSafeApply(EkstepEditorAPI.getAngularScope());
        setTimeout(function() {
            EkstepEditorAPI.getAngularScope().closeLoadScreen(); // added 2 sec set timeout to show the content load message           
        }, 2000)
    },
    getStageIcons: function() {
        return this.thumbnails;
    },
    toECML: function() {
        var instance = this;
        var content = { theme: { id: "theme", version: "1.0", startStage: this.stages[0].id, stage: [], manifest: { media: [] } } };
        this.setNavigationalParams();
        var mediaMap = {};
        _.forEach(this.stages, function(stage, index) {
            instance.thumbnails[stage.id] = stage.thumbnail;
            var stageBody = stage.toECML();
            _.forEach(stage.children, function(child) {
                var id = child.getManifestId();
                if (_.isUndefined(stageBody[id])) stageBody[id] = [];
                stageBody[id].push(child.toECML());
                instance.updateContentManifest(content, id, child.manifest);
                instance.addMediaToMediaMap(mediaMap, child.getMedia(), child.manifest);
            });
            content.theme.stage.push(stageBody);
        });    
        if(!_.isEmpty(EkstepEditor.mediaManager.migratedMediaMap)) {            
            instance.mergeMediaMap(mediaMap);
            content.theme["migration-media"] = {};
            content.theme["migration-media"].media =  _.values(EkstepEditor.mediaManager.migratedMediaMap);
        }
        content.theme.manifest.media = _.uniqBy(_.concat(content.theme.manifest.media, _.values(mediaMap)), 'id');
        
        return _.cloneDeep(content);
    },
    mergeMediaMap: function(mediaMap) {
        _.forIn(EkstepEditor.mediaManager.migratedMediaMap, function(value, key) {
            if (_.isUndefined(mediaMap[key])) {
                mediaMap[key] = value;
                value.src = EkstepEditor.mediaManager.getMediaOriginURL(value.src);
            }
        });
    },
    addMediaToMediaMap: function(mediaMap, media, manifest) {
        var pluginType = ['plugin', 'css'];
        if (_.isObject(media)) {
            _.forIn(media, function(value, key) {
                if(!mediaMap[key]) {
                    mediaMap[key] = value;
                    value.src = EkstepEditor.mediaManager.getMediaOriginURL(value.src);
                    _.forEach(pluginType, function(type) {
                        if (mediaMap[key].type === type) {
                            mediaMap[key].plugin = manifest.id;
                            mediaMap[key].ver = manifest.ver;
                        }
                    });
                } else if (value.preload) {
                    mediaMap[key].preload = value.preload;
                }
                
            });
        }
    },
    setNavigationalParams: function() {
        var instance = this;
        var size = this.stages.length;
        _.forEach(this.stages, function(stage, index) {
            if (index === 0) {
                stage.deleteParam('previous'); // first stage should not have previous param.
            }
            if (index !== 0) {
                stage.addParam('previous', instance.stages[index - 1].id);
            }
            if (index < (size - 1)) {
                stage.addParam('next', instance.stages[index + 1].id);
            }
            if (size === index + 1) {
                stage.deleteParam('next'); // last stage should not have next param.
            }
        });
    },
    updateContentManifest: function(content, id, pluginManifest) {
        var instance = this;
        if (_.indexOf(EkstepEditor.config.corePlugins, id) == 1) {
            return;
        }
        if (_.isUndefined(pluginManifest.renderer) || _.isUndefined(pluginManifest.renderer.main)) {
            return;
        }
        var manifestEntry = _.find(content.theme.manifest.media, { id: id });
        if (_.isUndefined(manifestEntry)) {
            //Add renderer dependencies first 
             if(!_.isUndefined(pluginManifest.renderer.dependencies) && pluginManifest.renderer.dependencies.length > 0) {
                _.forEach(pluginManifest.renderer.dependencies, function(dependency) {
                    
                    content.theme.manifest.media.push({
                        id: dependency.id,
                        type: dependency.type,
                        plugin: dependency.id,
                        ver: pluginManifest.ver,
                        src: instance._resolveManifestMediaPath(pluginManifest.id, pluginManifest.ver, dependency.src)
                    });
                });
            }
            //then push the main renderer file
            content.theme.manifest.media.push({
                id: id,
                plugin: id,
                ver: pluginManifest.ver,
                src: instance._resolveManifestMediaPath(pluginManifest.id, pluginManifest.ver, pluginManifest.renderer.main),
                type: "plugin"
            });
           
        }
    },
    fromECML: function(contentBody, stageIcons) {
        var instance = this;
        var startTime = (new Date()).getTime();
        EkstepEditorAPI.getAngularScope().appLoadMessage.push({ 'id': 3, 'message': 'Loading your lesson', 'status': false });
        EkstepEditorAPI.ngSafeApply(EkstepEditorAPI.getAngularScope());
        EkstepEditor.stageManager.contentLoading = true;
        EkstepEditor.eventManager.enableEvents = false;
        this._loadMedia(contentBody);
        this._loadPlugins(contentBody, function(err, res) {
            if(!err) {
                var stages = _.isArray(contentBody.theme.stage) ? contentBody.theme.stage : [contentBody.theme.stage];
                instance._loadStages(stages, stageIcons, startTime);
            }
        });
    },
    _loadMedia: function(contentBody) {
        _.forEach(contentBody.theme.manifest.media, function(media) {
            if (media.type == 'plugin' && EkstepEditor.pluginManager.isDefined(media.id)) {} else {
                EkstepEditor.mediaManager.addMedia(media);
            }
        });
        //if migratedMedia present inside theme, add to migrated media
        if (contentBody.theme["migration-media"]) {
            _.forEach(contentBody.theme["migration-media"].media, function(media){
                EkstepEditor.mediaManager.addToMigratedMedia(media);
            });
        }
    },
    _loadPlugins: function(contentBody, cb) {
        var instance = this;
        contentBody.theme.manifest.media = _.isArray(contentBody.theme.manifest.media) ? contentBody.theme.manifest.media : [contentBody.theme.manifest.media];
        var plugins = _.filter(contentBody.theme.manifest.media, { type: 'plugin' });
        var pluginMap = {}
        _.forEach(plugins, function(plugin) {
            pluginMap[plugin.id] = plugin.ver;
        });
        EkstepEditor.pluginManager.loadAllPlugins(pluginMap, cb);
    },
    _loadStages: function(stages, stageIcons, startTime) {
        var instance = this;
        stageIcons = stageIcons || '{}';
        var thumbnails = JSON.parse(stageIcons);
        var tasks = [];
        _.forEach(stages, function(stage, index) {
            tasks.push(function(callback) {
                instance._loadStage(stage, index, stages.length, thumbnails[stage.id], callback);
            });
        });
        if(tasks.length == 0) {
            instance.onContentLoad(startTime);
        } else {
            async.parallel(tasks, function(err, data) {
                instance.onContentLoad(startTime)
            });
        }
    },
    _loadStage: function(stage, index, size, thumbnail, callback) {
        var instance = this;
        var stageEvents = _.clone(stage.events) || {};
        var canvas = undefined;
        if(thumbnail) {
            canvas = {
                toDataURL: function() {
                    return thumbnail;
                },
                add: function() {},
                setActiveObject: function() {},
                clear: function() {},
                renderAll: function() {},
                setBackgroundColor: function() {}
            }
        } else {
            // Some extremely complex logic is happening here. Read at your own risk
            // Instantiate a canvas to create thumbnail.
            if(index == 0) {
                canvas = this.canvas;
            } else {
                $('<canvas>').attr({ id: stage.id }).css({ width: '720px', height: '405px' }).appendTo('#thumbnailCanvasContainer');
                canvas = new fabric.Canvas(stage.id, { backgroundColor: "#FFFFFF", preserveObjectStacking: true, width: 720, height: 405 });
            }
        }
        
        var stageInstance = EkstepEditorAPI.instantiatePlugin(EkstepEditor.config.corePluginMapping['stage'], stage);
        stageInstance.setCanvas(canvas);
        var pluginCount = 0;
        var props = _.pickBy(stage, _.isObject);
        var plugins = [];
        _.forIn(props, function(values, key) {
            values = _.isArray(values) ? values : [values];
            _.forEach(values, function(value) {
                plugins.push({ id: key, 'z-index': value['z-index'], data: value });
            });
            delete stage[key];
        })

        _.forIn(_.sortBy(plugins, 'z-index'), function(plugin) {
            var pluginId = EkstepEditor.config.corePluginMapping[plugin.id] || plugin.id;
            var pluginInstance;
            try {
                pluginInstance = EkstepEditorAPI.instantiatePlugin(pluginId, plugin.data, stageInstance);
                if (_.isUndefined(pluginInstance)) {
                    console.log('Unable to instantiate', plugin.id); // TODO: Add telemetry that plugin is not found
                    EkstepEditorAPI.instantiatePlugin("org.ekstep.unsupported", {data: plugin}, stageInstance);
                }
                pluginCount++;
            } catch(e) { 
                console.warn('error when instantiating plugin:', pluginId, plugin.data, stageInstance.id, e);                   
                EkstepEditor.telemetryService.error({ "env": "content", "stage": stageInstance.id, "action": "console log error", "err": "plugin instantiation", "type": "PORTAL", "data": "", "severity": "warn" });
            }                
        });
        if (stageEvents) {
            _.forEach(stageEvents, function(event) {
                _.forEach(event, function(e) {
                    stageInstance.addEvent(e);
                })
            })
        }
        stageInstance.destroyOnLoad(pluginCount, canvas, callback);
    },
    onContentLoad: function(startTime) {
        EkstepEditorAPI.jQuery('#thumbnailCanvasContainer').empty();
        EkstepEditorAPI.getAngularScope().toggleGenieControl();
        EkstepEditor.eventManager.enableEvents = true;
        EkstepEditor.stageManager.registerEvents();
        this.showLoadScreenMessage();
        EkstepEditor.stageManager.contentLoading = false;
        EkstepEditor.telemetryService.startEvent(true).append("loadtimes", {"contentLoad": ((new Date()).getTime() - startTime)});
        EkstepEditorAPI.dispatchEvent('content:load:complete');
        if(EkstepEditorAPI._.isEmpty(this.stages)) {
            EkstepEditor.eventManager.dispatchEvent('stage:create', { "position": "beginning" });
        } else {
            EkstepEditor.eventManager.dispatchEvent('stage:select', { stageId: this.stages[0].id });
        }
    },
    _resolveManifestMediaPath : function (id, ver, resource) {
        var src = EkstepEditor.pluginManager.resolvePluginResource(id, ver, resource);
        if (src === false) {
            return ""
        } else if(src.indexOf("http") === -1) {
            src = EkstepEditor.config.absURL + src;
        } 
        return src;
    },
    cleanUp: function() {
        this.stages = [];
        this.thumbnails = {};
        this.canvas = undefined;
        this.currentStage = undefined;
    }
}));

/**
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */
EkstepEditor.toolbarManager = new(Class.extend({
    menuItems: [],
    contextMenuItems: [],
    configMenuItems: [],
    scope: undefined,
    setScope: function(scope) {
        this.scope = scope;
    },
    registerMenu: function(menu) {
        if (!_.isObject(_.find(this.menuItems, { id: menu.id }))) {
            this.menuItems.push(menu);
        }
        //TODO: should be moved if possible
        EkstepEditor.jQuery(".ui.dropdown").dropdown();
        EkstepEditor.jQuery(".popup-item").popup();
    },
    registerContextMenu: function(menu) {
        if (!_.isObject(_.find(this.contextMenuItems, { id: menu.id }))) {
            this.contextMenuItems.push(menu);
        }
    },
    registerConfigMenu: function(menu) {
        if (!_.isObject(_.find(this.configMenuItems, { id: menu.id }))) {
            this.configMenuItems.push(menu);
        }
    },
    resetContextMenu: function() {
        _.forEach(this.contextMenuItems, function(cmenu) {
            cmenu.state = 'HIDE';
            cmenu.selected = false;
        });
    },
    updateContextMenu: function(menus) {
        var instance = this;
        _.forEach(menus, function(cmenu) {
            instance._updateContextMenu(cmenu.id, cmenu);
        });
        EkstepEditorAPI.ngSafeApply(this.scope, function() {
            instance.scope.contextMenus = instance.contextMenuItems;
        });
        EkstepEditor.jQuery(document).ready(function() {
            EkstepEditor.jQuery(".ui.dropdown").dropdown();
            EkstepEditor.jQuery(".popup-item").popup();
        });

    },
    _updateContextMenu: function(menuId, props) {
        //console.log('menu', menuId, 'props', props);
        var menu = _.find(this.contextMenuItems, { id: menuId });
        _.forIn(props, function(value, key) {
            if (key != 'data') {
                menu[key] = value;
                EkstepEditor.eventManager.dispatchEvent(menuId + ':' + key, props.data);
            }
        });
    },
    cleanUp: function() {
        this.menuItems = [];
        this.contextMenus = [];
        this.configMenuItems = [];
    }
}));

/**
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */
EkstepEditor.mediaManager = new(Class.extend({
    mediaMap: {},
    migratedMediaMap: {},
    addMedia: function(media) {
        if (_.isObject(media) && _.isString(media.id)) {
            this.mediaMap[media.id] = media;
        }
    },
    getMedia: function(asset) {
        return this.mediaMap[asset];
    },
    getMediaOriginURL: function(src) {
        var assetReverseProxyUrl = "/assets/public/";
        var replaceText = EkstepEditor.config.useProxyForURL ? (EkstepEditor.config.baseURL + assetReverseProxyUrl) : (EkstepEditor.config.absURL + assetReverseProxyUrl);        
        _.forEach(EkstepEditor.config.aws_s3_urls, function(url){
            if(src.indexOf(url) !== -1){
                src = src.replace(url, replaceText);
            }
        });
        return src;
    },
    addToMigratedMedia: function(media) {
        if (_.isObject(media) && _.isString(media.id)) {
            this.migratedMediaMap[media.id] = media;
        }
    }
}));

/**
 * @author Harish kumar Gangula<harishg@ilimi.in>
 */
EkstepEditor.resourceManager = new(Class.extend({
    init: function() {},
    discoverManifest: function(pluginId, pluginVer, cb, publishedTime) {
        async.waterfall([
            function(callback) {
                    EkstepEditor.hostRepo.discoverManifest(pluginId, pluginVer, callback, publishedTime); 
            },
            function(data, callback) {
                if (_.isUndefined(data.manifest)) {
                    EkstepEditor.draftRepo.discoverManifest(pluginId, pluginVer, callback, publishedTime);
                } else {
                    callback(null, data);
                }
            },
            function(data, callback) {
                if (_.isUndefined(data.manifest)) {
                    EkstepEditor.publishedRepo.discoverManifest(pluginId, pluginVer, callback, publishedTime); 
                } else {
                    callback(null, data);
                }
            }
        ], function(err, result) {
            if (result.manifest !== undefined)
                cb(undefined, result);
            else
                cb('Plugin not found in any repo or manifest', undefined);
        });

    },
    getResource: function(pluginId, pluginVer, src, dataType, repo, callback, publishedTime) {
        var resource = repo.resolveResource(pluginId, pluginVer, src);
        this.loadResource(resource, dataType, callback, publishedTime);
    },
    loadExternalResource: function(type, pluginId, pluginVer, src, repo, publishedTime) {
        var resource = repo.resolveResource(pluginId, pluginVer, src) + "?" + (publishedTime || "");
        switch (type) {
            case 'js':
                EkstepEditor.jQuery("body").append($("<script type='text/javascript' src=" + resource + ">"));
                break;
            case 'css':
                EkstepEditor.jQuery("head").append("<link rel='stylesheet' type='text/css' href='" + resource + "'>");
                break;
            default:
        }
    },
    loadResource: function(url, dataType, callback, publishedTime) {
        url = url + "?" + EkstepEditor.config.build_number
        if (publishedTime) {
            url = url + "&" + publishedTime;
        }
        EkstepEditor.jQuery.ajax({
            async: false,
            url: url ,
            dataType: dataType
        }).fail(function(err) {
            callback(err)
        }).done(function(data) {
            callback(null, data);
        });
    }
}));

/**
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */
EkstepEditor.keyboardManager = new (Class.extend({
	document: undefined,
	registry: {},
	initialize: function($document) {
		this.document = $document;
		var instance = this;
		$document.on("keydown", function(event) {
            instance.resolveKeyCombination(event);
        });
	},
	registerKeyCombination: function(command, callback) {
		commands = _.map(command.toUpperCase().split('+'), function(key) {
			return key.trim();
		});
		if(commands.length > 4) {
			throw "Cannot register a command with more than 3 keys";
		}
		var registryKey = ((_.indexOf(commands, 'CTRL') != -1 || _.indexOf(commands, 'CMD') != -1)  ? 'ctrl' : '') + (_.indexOf(commands, 'SHIFT') != -1 ? 'shift' : '') + (_.indexOf(commands, 'ALT') != -1 ? 'alt' : '');
		commands = _.filter(commands, function(key) {
			return _.indexOf(["CTRL", "CMD", "ALT", "SHIFT"], key) == -1
		});
		if(commands.length == 0) {
			throw "Cannot register a command only with modifier keys. Need one key character";
		}
		if(commands.length != 1) {
			throw "Cannot register a command with multiple key characters";
		}
		registryKey += (commands[0] === 'DEL') ? 8 : commands[0].charCodeAt(0);
		if(this.registry[registryKey]) throw "The given key combination is already registered. Please provide a different combination";
		this.registry[registryKey] = callback;
	},
	resolveKeyCombination: function(event) {
		var registryKey = ((event.metaKey || event.ctrlKey) ? 'ctrl' : '') + (event.shiftKey ? 'shift': '') + (event.altKey ? 'alt' : '') + event.keyCode;
		if(this.registry[registryKey]) {
			event.preventDefault();
			this.registry[registryKey]();
		}
	}
}));
/**
 * @author Harish kumar Gangula<harishg@ilimi.in>
 */
EkstepEditor.iRepo = Class.extend({
    discoverManifest: function(pluginId, pluginVer, callback) {
    	callback(undefined, undefined);
    },
    resolveResource: function(pluginId, pluginVer, resource) {}
});

/**
 * @author Harish kumar Gangula<harishg@ilimi.in>
 */
EkstepEditor.publishedRepo = new(EkstepEditor.iRepo.extend({
    id: "published",
    basePath: EkstepEditor.config.pluginRepo,
    discoverManifest: function(pluginId, pluginVer, callback, publishedTime) {
        var instance = this;
        EkstepEditor.resourceManager.loadResource(this.resolveResource(pluginId, pluginVer, "manifest.json"), "json", function(err, response) {
            callback(undefined, { "manifest": response, "repo": instance });
        }, publishedTime);
    },
    resolveResource: function(id, ver, resource) {
    	return this.basePath + "/" + id + "-" + ver + "/" + resource;
    }
}));

/**
 * @author Harish kumar Gangula<harishg@ilimi.in>
 */
EkstepEditor.draftRepo = new(EkstepEditor.iRepo.extend({
    id: "draft",
    basePath: EkstepEditor.config.pluginRepo,
    discoverManifest: function(pluginId, pluginVer, callback, publishedTime) {
        var instance = this;
        EkstepEditor.resourceManager.loadResource(this.resolveResource(pluginId, pluginVer, "manifest.json"), "json", function(err, response) {
            callback(undefined, { "manifest": response, "repo": instance });
        }, publishedTime);
    },
    resolveResource: function(id, ver, resource) {
    	return this.basePath + "/" + id + "-snapshot" + "/" + resource;
    }
}));

/**
 * @author Harish kumar Gangula<harishg@ilimi.in>
 */
EkstepEditor.hostRepo = new(EkstepEditor.iRepo.extend({
    id: "host",
    basePath: "https://localhost:8081",
    connected: false,
    init: function() {
    	var instance = this;
    	this.checkConnection(function(err, res) {
    		if(!err) {
            	instance.connected = true;
            }
    	});
    },
    checkConnection: function(cb) {
    	var instance = this;
    	EkstepEditor.resourceManager.loadResource(this.basePath + "/list", "json", cb);
    },
    discoverManifest: function(pluginId, pluginVer, callback, publishedTime) {
        if(this.connected) {
            var instance = this;
            EkstepEditor.resourceManager.loadResource(this.resolveResource(pluginId, pluginVer, "manifest.json"), "json", function(err, response) {
                callback(undefined, { "manifest": response, "repo": instance });
            }, publishedTime);
        } else {
            callback(undefined, { "manifest": undefined, "repo": undefined });
        }
    },
    resolveResource: function(pluginId, pluginVer, resource) {
    	return this.basePath + "/" + pluginId + "-" + pluginVer + "/" + resource;
    }
}));

/**
 * The EkStep Editor API is the core interface of the plugins with the rest of the editor framework. It allows the plugins
 * to access the framework resources, launch popups, and handle events raised by the framework. Plugins should not call any
 * other framework classes directly.
 * 
 * @class EkstepEditorAPI
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */
window.EkstepEditorAPI = {
    /**
     * Handle for JQuery. All plugins should use this instead of using '$' directly
     * 
     * @member {Object} jQuery
     * @memberof EkstepEditorAPI
     */
    jQuery: EkstepEditor.jQuery,

    /**
     * Handle for Lodash Library. All plugins should use this instead of using '_' directly
     * 
     * @member {Object} _
     * @memberof EkstepEditorAPI
     */
    _: EkstepEditor._,

    /**
     * @deprecated since current version. This will be removed after April Release
     * Object to hold global context
     * 
     * @member {Object} _
     * @memberof EkstepEditorAPI
     */
    globalContext: undefined, // TODO: Deprecate the variable

    /**
     * @deprecated since current version. This will be removed after April Release
     * Object to hold Base URL
     * 
     * @member {String} baseURL
     * @memberof EkstepEditorAPI
     */
    baseURL: EkstepEditor.config.baseURL,

    /**
     * @deprecated since current version. This will be removed after April Release
     * Object to hold absolute URL
     * 
     * @member {String} absURL
     * @memberof EkstepEditorAPI
     */
    absURL: undefined,

    /**
     * @deprecated since current version. This will be removed after April Release
     * Object to hold API slug for API reverse proxy
     * 
     * @member {String} apislug
     * @memberof EkstepEditorAPI
     */
    apislug: EkstepEditor.config.apislug,

    /**
     * Add an object to the context
     * 
     * @param {String} key   Key
     * @param {Object} value Value
     * @memberof EkstepEditorAPI
     */
    setContext: function(key, value) {
        EkstepEditor.globalContext[key] = value;
    },

    /**
     * Get the context variable
     * 
     * @param  {String} key Key
     * @return {object}     Value
     * @memberof EkstepEditorAPI
     */
    getContext: function(key) {
        return EkstepEditor.globalContext[key];
    },

    /**
     * Get all context attributes
     * @return {map} Map of key values
     */
    getAllContext: function() {
        return EkstepEditor.globalContext;
    },

    /**
     * Add or update a configuration property
     * 
     * @param {String} key   Key
     * @param {Object} value Value
     * @memberof EkstepEditorAPI
     */
    setConfig: function(key, value) {
        EkstepEditor.config[key] = value;
    },

    /**
     * Get the config variable
     * 
     * @param  {String} key Key
     * @return {object}     Value
     * @memberof EkstepEditorAPI
     */
    getConfig: function(key) {
        return EkstepEditor.config[key];
    },

    /**
     * Get all config attributes
     * @return {map} Map of key values
     */
    getAllConfig: function() {
        return EkstepEditor.config;
    },

    /**
     * Register an event listener callback function for the events raised by the framework.
     * @param type {string} name of the event (e.g. org.ekstep.quickstart:configure)
     * @param callback {function} callback function
     * @param scope {object} the scope of the callback (use this)
     * @memberof EkstepEditorAPI
     */
    addEventListener: function(type, callback, scope) {
        EkstepEditor.eventManager.addEventListener(type, callback, scope);
    },

    /**
     * Fires an event to the framework, allowing other plugins who may have registered to receive the callback notification. All
     * communication between the framework and other plugins is via the events.
     * @param type {string} name of the event to fire (e.g. org.ekstep.quickstart:configure)
     * @param data {object} event data to carry along with the notification
     * @param target {object} the scope of the event (use this)
     * @memberof EkstepEditorAPI
     */
    dispatchEvent: function(type, data, target) {
        EkstepEditor.eventManager.dispatchEvent(type, data, target);
    },

    /**
     * Remove an event listener to an event. Plugins should cleanup when they are removed.
     * @param type {string} name of the event registered with (e.g. org.ekstep.quickstart:configure)
     * @param callback {function} remove the callback function
     * @param scope {object} the scope of the event (use this)
     * @memberof EkstepEditorAPI
     */
    removeEventListener: function(type, callback, scope) {
        EkstepEditor.eventManager.removeEventListener(type, callback, scope);
    },

    /**
     * Framework support to load plugin resources. When the resources are loaded, the callback is fired.
     * @param pluginId {string} id of the plugin requesting resource to be loaded
     * @param pluginVer {string} version of the plugin that is requesting the resource to be loaded
     * @param src {string} URL of the resource to be loaded
     * @param dataType {object} dataType of the resource (image, or audio)
     * @param callback {function} callback function whent he resource is available
     * @memberof EkstepEditorAPI
     */
    loadPluginResource: function(pluginId, pluginVer, src, dataType, callback) {
        EkstepEditor.pluginManager.loadPluginResource(pluginId, pluginVer, src, dataType, callback);
    },

    /**
     * Returns the handle to the Angular services. The services can be used by plugisn to achieve
     * the functional calls or render custom views. Valid services are:
     *     popup - UI service to render popup
     *     content - Provides access to the content API (for loading templates and assets)
     *     assessment - Provides access to the assessment API (for loading questions)
     *     language - Provides access to the wordnet API (for loading words and aksharas)
     *     search - Provides access to search API (for search activities, question, domains)
     *     meta - Provides access to metadata API (for resource bundles, ordinals, definitions)
     *     asset - Provides access to the content API (for save assets)
     *     telemetry - Service to genarate and log telemetry events
     * @param serviceId {string} id of the service to return. Returns undefined if the id is invalid
     * @memberof EkstepEditorAPI
     */
    getService: function(serviceId) {
        var service = '';
        switch (serviceId) {
            case ServiceConstants.POPUP_SERVICE:
                service = EkstepEditor.popupService;
                break;
            case ServiceConstants.CONTENT_SERVICE:
                service = EkstepEditor.contentService;
                break;
            case ServiceConstants.ASSESSMENT_SERVICE:
                service = EkstepEditor.assessmentService;
                break;
            case ServiceConstants.LANGUAGE_SERVICE:
                service = EkstepEditor.languageService;
                break;
            case ServiceConstants.SEARCH_SERVICE:
                service = EkstepEditor.searchService;
                break;
            case ServiceConstants.META_SERVICE:
                service = EkstepEditor.metaService;
                break;
            case ServiceConstants.ASSET_SERVICE:
                service = EkstepEditor.assetService;
                break;
            case ServiceConstants.TELEMETRY_SERVICE:
                service = EkstepEditor.telemetryService;
                break;
        }
        return service;
    },

    /**
     * Returns the angular scope object for the plugins that need angular framework to render. The editor
     * uses Angular 2 and plugins must use this to access the scope instead of instantiating Angular by
     * themselves.
     * @memberof EkstepEditorAPI
     */
    getAngularScope: function() {
        return EkstepEditor.toolbarManager.scope;
    },

    /**
     * Returns the HTML5 canvas for rendering on the editor. By default, the editor uses Fabric.js and recommends
     * the plugins to also use Fabric.js for rendering the WYSIWYG components on the editor canvas. However,
     * this method provides access to the underlying native HTML5 canvas if needed. For example, if your plugin
     * uses some other third-party graphics library for rendering.
     * @memberof EkstepEditorAPI
     */
    getCanvas: function() {
        return EkstepEditor.stageManager.canvas;
    },

    /**
     * Retrns the current stage object to the plugin. Plugins might use this to query other objects on the
     * canvas or access other stage context.
     * @memberof EkstepEditorAPI
     */
    getCurrentStage: function() {
        return EkstepEditor.stageManager.currentStage;
    },

    /**
     * Retrns the specified stage to the plugin. This can be used to build scenarios where a plugin might be
     * linking multiple stages together (e.g. when building navigation plugins).
     * @memberof EkstepEditorAPI
     */
    getStage: function(stageId) {
        return EkstepEditor.stageManager.getStage(stageId);
    },

    /**
     * Refreshes the rendering of stages - plugins can request the stages to be refreshed if any change
     * has been made.
     * @memberof EkstepEditorAPI
     */
    refreshStages: function() {
        //EkstepEditor.toolbarManager.scope.safeApply(function() { EkstepEditor.toolbarManager.scope.stages = EkstepEditor.stageManager.stages; });
        /* istanbul ignore next */
        EkstepEditorAPI.ngSafeApply(EkstepEditorAPI.getAngularScope(), function() { EkstepEditor.toolbarManager.scope.stages = EkstepEditor.stageManager.stages; });
    },

    /**
     * Returns the currently selected active object on the canvas. This can be used by plugins to provide
     * contextual support - e.g. show words for a given text object when the text is selected.
     * @memberof EkstepEditorAPI
     */
    getCurrentObject: function() {
        var activeObj = EkstepEditor.stageManager.canvas.getActiveObject();
        if (!activeObj) return false;
        var pluginId = activeObj.id;
        return EkstepEditorAPI.getPluginInstance(pluginId);
    },

    /**
     * Returns the current group of selected objects. This is possible when a user does multi-select by
     * clicking on multiple objects or by panning on the canvas.
     * @memberof EkstepEditorAPI
     */
    getCurrentGroup: function() {
        var plugins = EkstepEditor.stageManager.canvas.getActiveGroup()._objects;
        var group = [];
        _.forEach(plugins, function(plugins, index) {
            var obj = EkstepEditorAPI.getPluginInstance(plugins.id);
            group.push(obj);
        });
        return group;
    },

    /**
     * Retrns the current group on the fabric canvas. This provides access to the fabric object. If you
     * want to access the plugin instance that is currently selected, use getCurrentGroup() instead.
     * @memberof EkstepEditorAPI
     */
    getEditorGroup: function() {
        var group = EkstepEditor.stageManager.canvas.getActiveGroup();
        return group;
    },

    /**
     * Retrns the current object on the fabric canvas. This provides access to the fabric object. If you
     * want to access the plugin instance that is currently selected, use getCurrentObject() instead.
     * @memberof EkstepEditorAPI
     */
    getEditorObject: function() {
        return EkstepEditor.stageManager.canvas.getActiveObject();
    },

    /**
     * Notifies the framework to render the canvas once again. This can be done by the plugin when
     * its config or state is modified via the config views.
     * @memberof EkstepEditorAPI
     */
    render: function() {
        EkstepEditor.stageManager.canvas.renderAll();
    },

    /**
     * Returns a plugin instance for the given plugin ID. Plugins can use this work with dependencies
     * or build plugins that enhance the behavior of other plugins.
     * @memberof EkstepEditorAPI
     */
    getPluginInstance: function(pluginId) {
        return EkstepEditor.pluginManager.getPluginInstance(pluginId);
    },

    /**
     * Allows the plugins to request an update to the context menu when one or more objects are selected.
     * This can be used by a plugin to add more actions to the context menu - e.g. when a text is selected,
     * a word parser plugin can add context menu for spell check, or for adding word definition popups.
     * @param menu {object} Menu item to add - see the manifest for the structre of the menu item
     * @memberof EkstepEditorAPI
     */
    updateContextMenu: function(menu) {
        EkstepEditor.toolbarManager.updateContextMenu([menu]);
    },

    /**
     * Allows the plugins to request an update to the context menu by supplying multiple menu items.
     * This can be used by a plugin to add more actions to the context menu - e.g. when a text is selected,
     * a word parser plugin can add context menu for spell check, or for adding word definition popups.
     * @param menu {array} Array of menu items to add - see the manifest for the structre of the menu item
     * @memberof EkstepEditorAPI
     */
    updateContextMenus: function(menus) {
        EkstepEditor.toolbarManager.updateContextMenu(menus);
    },

    /**
     * Allows the plugins to request loading and instantiating another plugin. This is useful when
     * a plugin depends upon other plugins - e.g. a wordpicker might dependend upon an asset picker.
     * @param id {string} Fully qualified plugin id to load and instantiate
     * @param data {object} Data to be passed during instantiation (initial state)
     * @param parent {object} Parent scope - use this
     * @param override {object} Any function overrides - e.g. you can override the handlers of the plugin
     * @see org.ekstep.composite-text-image-shape plugin for a sample of leveraging this.
     * @memberof EkstepEditorAPI
     */
    instantiatePlugin: function(id, data, parent, override) {
        return EkstepEditor.pluginManager.invoke(id, data, parent, override);
    },

    /**
     * Plugins can instantiate a stage and add it to the content. This can be done by special plugins that
     * work at a stage level or cause multiple stages to be added based on the configuration.
     * @param stage {object} Stage to add to the content
     * @memberof EkstepEditorAPI
     */
    addStage: function(stage) {
        EkstepEditor.stageManager.addStage(stage);
    },

    /**
     * Lookup for another plugin in the current plugin manager scope.
     * @param id {string} Plugin id to return. Undefined if the plugin has not been loaded.
     * @memberof EkstepEditorAPI
     */
    getPlugin: function(id) {
        return EkstepEditor.pluginManager.plugins[id];
    },

    /**
     * Adds a plugin instance to the manager. This may be used when a plugin instantiates other plugins. The
     * newly instantiated plugins are added to the framework's registry, making them discoverable by others.
     * Useful for scenarios where plugins depend on others, or composite plugins.
     * @param pluginInstance {object} Plugin object instantiated by this plugin.
     * @memberof EkstepEditorAPI
     */
    addPluginInstance: function(pluginInstance) {
        EkstepEditor.pluginManager.addPluginInstance(pluginInstance);
    },

    /**
     * Removes a plugin instance from the manager. Do this only if you instantiated the plugin using addPluginInstance()
     * @param pluginInstance {object} Plugin object instantiated by this plugin.
     * @memberof EkstepEditorAPI
     */
    removePluginInstance: function(pluginInstance) {
        EkstepEditor.pluginManager.removePluginInstance(pluginInstance);
    },

    /**
     * Creates a deep copy of the given plugin object with an offset x and y position. This is useful when
     * you are building plugins that enable copy paste type functionality for example.
     * @param pluginInstance {object} Plugin object instantiated by this plugin.
     * @memberof EkstepEditorAPI
     */
    cloneInstance: function(plugin) {
        var data = plugin.getCopy();
        data = _.omit(data, ["id", "event"]);
        if (plugin.parent.id == EkstepEditorAPI.getCurrentStage().id) {
            data.x = data.x + 2;
            data.y = data.y + 2;
        }
        EkstepEditorAPI.instantiatePlugin(plugin.manifest.id, data, EkstepEditorAPI.getCurrentStage());
    },

    /**
     * Returns all stages in the current document. This could be useful when plugins work across stages
     * such as timers that work across stages or page number plugins. Using this, a plugin can get access to all
     * stages, and instantiate plugins on each stage.
     * @memberof EkstepEditorAPI
     */
    getAllStages: function() {
        return EkstepEditor.stageManager.stages;
    },

    /**
     * Selector for plugins of a given type in the document. This can be used by plugins to discover other
     * instances of the same plugin, or other plugins that are compatible with this plugin. E.g. a wordnet
     * plugin might use this to discover all other text plugins in the content.
     * 
     * @param  {String} stage        Stage ID
     * @param  {Array} includeTypes Include plugins
     * @param  {Array} excludeTypes Exclude plugins
     * @param  {Array} excludeIds   Exclude specific plugin instances
     * @return {Array}              Array of plugin instances matching the given criteria
     * @memberof EkstepEditorAPI
     */
    getStagePluginInstances: function(stage, includeTypes, excludeTypes, excludeIds) {
        // TODO: Add logic to check if stage exists
        var instances = _.clone(EkstepEditorAPI.getStage(stage).children);
        if (includeTypes) {
            instances = _.filter(instances, function(obj) {
                return includeTypes.indexOf(obj.manifest.id) != -1;
            });
        }
        if (excludeTypes) {
            instances = _.filter(instances, function(obj) {
                return excludeTypes.indexOf(obj.manifest.id) == -1;
            });
        }
        if (excludeIds) {
            instances = _.filter(instances, function(obj) {
                return excludeIds.indexOf(obj.id) == -1;
            });
        }
        return instances;
    },

    /**
     * Get matching plugin instances. This function returns instances across all stages matching the given criteria
     * 
     * @param  {Array} includeTypes Include plugins
     * @param  {Array} excludeTypes Exclude plugins
     * @param  {Array} excludeIds   Exclude specific plugin instances
     * @return {Array}              Array of plugin instances matching the given criteria
     * @memberof EkstepEditorAPI
     */
    getPluginInstances: function(includeTypes, excludeTypes, excludeIds) {
        var instances = _.clone(EkstepEditor.pluginManager.pluginInstances);
        if (includeTypes) {
            instances = _.filter(instances, function(obj) {
                return includeTypes.indexOf(obj.manifest.id) != -1;
            });
        }
        if (excludeTypes) {
            instances = _.filter(instances, function(obj) {
                return excludeTypes.indexOf(obj.manifest.id) == -1;
            });
        }
        if (excludeIds) {
            instances = _.filter(instances, function(obj) {
                return excludeIds.indexOf(obj.id) == -1;
            });
        }
        return instances;
    },

    /**
     * Allows plugins to load a media object that they may depend upon.
     * @param assetId {string} ID of the media asset to load
     * @memberof EkstepEditorAPI
     */
    getMedia: function(assetId) {
        return EkstepEditor.mediaManager.getMedia(assetId);
    },

    /**
     * Get the media asset's reverse proxy URL
     * @param  {String} url Fully qualified URL
     * @return {String}     Reverse proxied URL
     * @memberof EkstepEditorAPI
     */
    getMediaReverseProxyURL: function(url) {
        return EkstepEditor.mediaManager.getMediaOriginURL(url);
    },

    /**
     * API to load a plugin dynamically. Any plugin to be loaded should be ideally declared as dependency in the manifest.
     * 
     * @param  {String} pluginId      Plugin ID
     * @param  {String} pluginVersion Plugin Version
     * @memberof EkstepEditorAPI
     */
    loadPlugin: function(pluginId, pluginVersion) {
        EkstepEditor.pluginManager.loadPlugin(pluginId, pluginVersion);
    },

    /**
     * @deprecated
     * Method to get plugin rep
     * 
     * @return {String} Repo location of published plugins
     * @memberof EkstepEditorAPI
     */
    getPluginRepo: function() {
        return EkstepEditor.config.pluginRepo;
    },

    /**
     * Utility API to update the plugin dimenstions once any action like - move, resize etc are performed
     * 
     * @param  {Object} inst Plugin Instance
     * @memberof EkstepEditorAPI
     */
    updatePluginDimensions: function(inst) {
        inst.attributes.x = inst.editorObj.getLeft();
        inst.attributes.y = inst.editorObj.getTop();
        inst.attributes.w = inst.editorObj.getWidth() - inst.editorObj.getStrokeWidth();
        inst.attributes.h = inst.editorObj.getHeight() - inst.editorObj.getStrokeWidth();
        inst.attributes.rotate = inst.editorObj.getAngle();
        if (_.isFunction(inst.editorObj.getRx))
            inst.attributes.r = inst.editorObj.getRx();
    },
    ngSafeApply: function(scope, fn) {
        if (scope) scope.$safeApply(fn);
    },
    /**
     * API to load and initialize a plugin to the current stage
     * 
     * @param  {String} pluginId      Plugin ID
     * @param  {String} pluginVersion Plugin Version
     * @param  {Long} publishedTime   Plugin published timestamp (for cache busting)
     * @memberof EkstepEditorAPI
     */
    loadAndInitPlugin: function(pluginId, pluginVersion, publishedTime) {
        EkstepEditor.pluginManager.loadAndInitPlugin(pluginId, pluginVersion, publishedTime);
    },

    /**
     * API to Resolve plugin resource URL. This API would resolve to the repo the plugin is loaded from.
     * 
     * @param  {String} pluginId      Plugin ID
     * @param  {String} pluginVersion Plugin Version
     * @param  {String} resource resource relative URL
     * @return {String}          Resolved URL
     * @memberof EkstepEditorAPI
     */
    resolvePluginResource: function (id, ver, resource) {
         return EkstepEditor.pluginManager.resolvePluginResource(id, ver, resource);
    },

    /**
     * API to register for a keyboard command
     * 
     * @param  {String}   command  Key combination. For ex: ctrl+s, ctrl+c etc
     * @param  {Function} callback Callback to invoke when the key is pressed
     * @memberof EkstepEditorAPI
     */
    registerKeyboardCommand: function(command, callback) {
        EkstepEditor.keyboardManager.registerKeyCombination(command, callback);
    }
}

'use strict';

EkstepEditor.migration = new(Class.extend({
    init: function() {
        console.log('migration task initialized');
        EkstepEditorAPI.addEventListener('content:migration:start', this.execute, this);
    },
    _startTime: undefined,
    tasks: ['mediamigration_task', 'basestage_task', 'orderstage_task', 'scribblemigration_task', 'imagemigration_task', 'readalongmigration_task', 'assessmentmigration_task', 'eventsmigration_task', 'settagmigration_task'],
    migrationErrors: [],
    execute: function(event, data) {
        var contentbody = data.body, stageIcons = data.stageIcons;

        if (!_.has(contentbody, 'theme.stage')) EkstepEditor.telemetryService.error({ "env": "migration", "stage": "", "action": "log the error", "err": "migration has errors", "type": "PORTAL", "data": "", "severity": "warn" });  
        if (this.isOldContent(contentbody)) {            
            this.initLoadScreenMsg();
            this._startTime = (new Date()).getTime();
            _.forEach(this.tasks, function(task) {
                EkstepEditor.migration[task].migrate(contentbody)
            });
            this.postMigration(contentbody, stageIcons);
        } else {
            console.info('no need for migration');
            EkstepEditor.stageManager.fromECML(contentbody, stageIcons);
        }
    },
    postMigration: function(content, stageIcons) {
        var instance = this;
        EkstepEditor.telemetryService.startEvent().append("loadtimes", { migration: ((new Date()).getTime() - instance._startTime) });
        instance.setNewVersion(content);
        instance.showLoadScreenMsg();        
        console.info('Migration task completed!');        
        console.log('after migration content:', _.cloneDeep(content));
        if (instance.migrationErrors.length) {            
            console.info('Migration has errors: ', instance.migrationErrors);
            EkstepEditor.telemetryService.error({ "env": "migration", "stage": "", "action": "log the error", "err": "migration has errors", "type": "PORTAL", "data": "", "severity": "warn" });
        }

        EkstepEditor.stageManager.fromECML(content, stageIcons);
    },
    isOldContent: function(contentbody) {
        var version = contentbody.theme.version || contentbody.theme.ver;
        if (typeof version == 'string') version = parseFloat(version);
        if (version < 1) return true;
        return false;
    },
    initLoadScreenMsg: function() {
        var scope = EkstepEditorAPI.getAngularScope();
        scope.appLoadMessage.push({ 'id': 2, 'message': 'Migrating Content', 'status': false });
        scope.migrationFlag = true;
    },
    showLoadScreenMsg: function () {
        var scope = EkstepEditorAPI.getAngularScope();
        scope.migration.showPostMigrationMsg = true;
        scope.migration.showMigrationSuccess = true;
        var obj = _.find(EkstepEditorAPI.getAngularScope().appLoadMessage, { 'id': 2 });
        if (_.isObject(obj)) {
            obj.message = "Content migrated";
            obj.status = true;
        }
        EkstepEditorAPI.ngSafeApply(scope);
    },
    setNewVersion: function(contentbody) {
        if (_.has(contentbody, 'theme.ver')) delete contentbody.theme.ver;
        contentbody.theme.version = "1.0";
    }
}));

'use strict';

EkstepEditor.migration.mediamigration_task = new(Class.extend({
    init: function() {
        console.log('media migration task initialized');
    },
    migrate: function(contentbody) {
        _.forEach(contentbody.theme.manifest.media, function(media){
           EkstepEditor.mediaManager.addToMigratedMedia(media); 
        });
    }
}));

'use strict';

EkstepEditor.migration.orderstage_task = new(Class.extend({
    init: function() {
        console.log('orderstage-task initialized');
    },
    migrate: function(contentbody) {
        var nextStage = {},
            stage,
            contentstages = [],
            instance = this,
            stageIds = [];

        nextStage.value = (!_.isUndefined(contentbody)) ? contentbody.theme.startStage : undefined;
        var stages = _.clone(contentbody.theme.stage);
        for (var i = 0; i < contentbody.theme.stage.length; i++) {
            if (!_.isUndefined(nextStage.value)) {
                stage = _.find(stages, function(st) {
                    return st.id === nextStage.value;
                });
                if(!_.isUndefined(stage)){
                    contentstages.push(stage);
                    var index = _.findIndex(stages, function(s) {
                        return s.id == nextStage.value;
                    });
                    stages.splice(index, 1);
                    if (_.isArray(stage.param) && !_.isUndefined(stage.param)) {
                        _.forEach(stage.param, function(param) {
                            if (param.name === 'next')
                                nextStage.value = param.value;
                        });
                    } else if (!_.isUndefined(stage.param) && stage.param.name === 'next') {
                        nextStage.value = stage.param.value;
                    } else {
                        nextStage.value = undefined;
                    }
                }
            }
            if (contentbody.theme.stage.length === i + 1) {
                contentbody.theme.stage = contentstages.concat(stages);
            }
        }
    }
}));

'use strict';

EkstepEditor.migration.basestage_task = new(Class.extend({
    init: function() {
        console.log('basestage_task initialized');
    },
    baseStage: undefined,
    contentbody: undefined,    
    migrate: function(contentbody) {
        var instance = this,
            stageId,
            baseStageArray = [];

            instance.contentbody = contentbody;
        if (!_.isArray(instance.contentbody.theme.stage)) instance.contentbody.theme.stage = [instance.contentbody.theme.stage];
        _.forEach(instance.contentbody.theme.stage, function(stage, index) {
            var mergedObject = {}
            if (stage.extends) {
                instance.baseStage = _.find(contentbody.theme.stage, function(o) { return o.id === stage.extends });
                //merge stage with basestage                
                for (var attr in instance.baseStage) { mergedObject[attr] = instance.baseStage[attr] }
                for (var attr in stage) { mergedObject[attr] = stage[attr] }                
                stage = mergedObject;                 
                delete instance.contentbody.theme.stage[index].extends;
                baseStageArray.push(instance.baseStage.id);
            }
            if (contentbody.theme.stage.length === index + 1) {
                if (baseStageArray.length) {
                    _.forEach(baseStageArray, function(bs, index){ 
                        instance.removeBaseStage(bs);
                    });
                }                
            }
        });
    },
    removeBaseStage: function(baseStage) {
        var instance = this;
        if (baseStage) {
            _.remove(instance.contentbody.theme.stage, function(s) {
                return s.id === baseStage;
            });
        }
    }
}));

'use strict';

EkstepEditor.migration.imagemigration_task = new(Class.extend({
    init: function() {
        console.log('image migration initialized');
    },
    migrate: function(contentbody) {},
    removeImage: function(stage, id) {
        _.remove(stage.image, function(image) {
            return image.asset === id;
        });
    }
}));

'use strict';

EkstepEditor.migration.scribblemigration_task = new(Class.extend({
    init: function() {
        console.log('scribble migration task initialized');
    },
    id: 'org.ekstep.scribblepad',    
    migrate: function(contentbody) {
    	var instance = this;

        _.forEach(contentbody.theme.stage, function(stage, index) {
            if (stage.scribble && (!_.isArray(stage.scribble))) stage.scribble = [stage.scribble];
            if (stage.scribble && stage.scribble.length) {
                stage[instance.id] = stage.scribble;
                delete stage.scribble;
            }            
            EkstepEditor.migration.imagemigration_task.removeImage(stage, 'domain_38441_trash');                
            instance.removeEraserMedia(contentbody);
        });
    },
    removeEraserMedia: function(contentbody) {
        _.forEach(_.clone(contentbody.theme.manifest.media), function(media, index) {
            if (media.assetId === "domain_38441_trash") contentbody.theme.manifest.media.splice(index, 1);
        });
    }
}))

'use strict';

EkstepEditor.migration.readalongmigration_task = new(Class.extend({
    init: function() {
        console.log('read along migration task initialized');
    },
    // check 'isReadAlongAutoPlay' attribute in htext and convert to 'autoplay'
    migrate: function(contentbody) {
    		console.log('migrating readalong');
        _.forEach(contentbody.theme.stage, function(stage, index) {
            if (stage.htext && (!_.isArray(stage.htext))) stage.htext = [stage.htext];
            if (stage.htext && stage.htext.length) {
                _.forEach(stage.htext, function(htext) {
                    if(!_.isUndefined(htext.isReadAlongAutoPlay)) {
                        htext.autoplay = htext.isReadAlongAutoPlay;
                        delete htext.isReadAlongAutoPlay;
                    }
                });
            }
        });
    }
}));

'use strict';

EkstepEditor.migration.assessmentmigration_task = new(Class.extend({
    init: function() {
        console.log('assessment migration task initialized');
    },
    contentbody: undefined,
    template: [],
    id: 'org.ekstep.quiz',
    quiz: { x: 0, y: 0, w: 0, h: 0, visible: true, editable: true, 'z-index': 0, data: { __cdata: { questionnaire: {}, template: [] } }, config: { __cdata: { "type": "items", "var": "item" } } },
    migrate: function(contentbody) {
        var instance = this;
        this.contentbody = contentbody;

        _.forEach(contentbody.theme.stage, function(stage, index) {
            if(!_.isUndefined(stage.g) && !_.isArray(stage.g)) stage.g = [stage.g];
            if (!_.isUndefined(stage.iterate) && (_.has(stage, 'embed') || _.find(stage.g, function(g){return _.has(g, 'embed')}))) {
                instance.transformToQuiz(stage);
                instance.removeObsoleteTag(stage);              
            }
        });

    },
    getController: function(controllerId) {
        return _.find(this.contentbody.theme.controller, function(ctrl) {
            return ctrl.id === controllerId;
        });
    },
    getTemplate: function(templateId) {        
        return _.find(this.contentbody.theme.template, function(template) {
            return template.id === templateId;
        });        
    },
    transformToQuiz: function(stage) {
        var instance = this,
            questionnaire,
            quiz,
            controllerData,
            ctrl,
            tmplt;

        quiz = _.cloneDeep(instance.quiz);
        ctrl = instance.getController(stage.iterate);
        _.isUndefined(ctrl) ? EkstepEditor.migration.migrationErrors.push('controller not found for assessment on stage: '+ stage.id) : (controllerData = ctrl.__cdata);
        if(typeof controllerData === 'string') controllerData = JSON.parse(controllerData);
        questionnaire = quiz.data.__cdata.questionnaire = controllerData;
        if (questionnaire) {
            _.forEach(questionnaire.item_sets, function(itemset, index) {

                _.forEach(questionnaire.items[itemset.id], function(items) {
                    if (items.template) {
                        tmplt = instance.getTemplate(items.template);
                        _.isUndefined(tmplt) ? EkstepEditor.migration.migrationErrors.push('Template not found for assessment on stage: ' + stage.id) : quiz.data.__cdata.template.push(tmplt);
                        //instance.removeObsoleteTemplate(items.template);
                    }
                });

                if (questionnaire.item_sets.length === index + 1) {
                    stage[instance.id] = quiz;
                    instance.stringifycdata(stage);
                };
            });
        }
    },
    removeObsoleteTag: function(stage) {
        if (_.has(stage, 'embed')) delete stage.embed;
        if (_.has(stage, 'g')) _.remove(stage.g, function(g){return _.has(g, 'embed')});        
        if (_.has(stage, 'appEvents')) delete stage.appEvents;
        delete stage.iterate;
    },
    removeObsoleteTemplate: function(templateId) {
    	return _.remove(this.contentbody.theme.template, function(template){
    		return template.id === templateId;
    	});
    },
    stringifycdata: function(stage) {
        stage[this.id].data.__cdata = JSON.stringify(stage[this.id].data.__cdata);
        stage[this.id].config.__cdata = JSON.stringify(stage[this.id].config.__cdata);
    }
}));

'use strict';

EkstepEditor.migration.eventsmigration_task = new(Class.extend({
    init: function() {
        console.log('events migration task initialized');
    },
    migrate: function(contentbody) {
        console.log('migrating events');
        var instance = this;
        _.forEach(contentbody.theme.stage, function(stage, index) {
            var plugins = _.pickBy(stage, _.isObject);
            if (!_.isArray(plugins)) plugins = [plugins];
            _.forEach(plugins, function(pluginTypes) {
                if (!_.isArray(pluginTypes)) pluginTypes = [pluginTypes];
                _.forEach(pluginTypes, function(plugin) {
                    _.forEach(plugin, function(pluginInstances) {
                        if (_.isArray(pluginInstances)) {
                            _.forEach(pluginInstances, function(pi) {
                                if (pi && (pi.event || pi.events)) {
                                    if (pi.event) {
                                        var event = _.clone(pi.event, true);
                                        delete pi.event;
                                        instance.migrateEvents(event, pi);
                                    }
                                    if (pi.events && pi.events.event) {
                                        var events = _.clone(pi.events.event, true);
                                        delete pi.events;
                                        instance.migrateEvents(events, pi);
                                    }
                                }
                            })
                        } else {
                            if (pluginInstances && (pluginInstances.event || pluginInstances.events)) {
                                if (pluginInstances.event) {
                                    var event = _.clone(pluginInstances.event, true);
                                    delete pluginInstances.event;
                                    instance.migrateEvents(event, pluginInstances);
                                }
                                if (pluginInstances.events && pluginInstances.events.event) {
                                    var events = _.clone(pluginInstances.events.event, true);
                                    delete pluginInstances.events;
                                    instance.migrateEvents(events, pluginInstances);
                                }
                            }
                        }
                    })
                })
            })
            if (stage.event || stage.events) {
                if (stage.event) {
                    var stageEvent = _.clone(stage.event, true);
                    delete stage.event;
                    instance.migrateStageEvents(stageEvent, stage);
                }
                if (stage.events && stage.events.event) {
                    var stageEvents = _.clone(stage.events.event, true);
                    delete stage.events;
                    instance.migrateStageEvents(stageEvents, stage);
                }
            }
        });
    },
    migrateStageEvents: function(events, pi) {
        var instance = this;
        if (_.isArray(events)) {
            _.forEach(events, function(event) {
                if (event.action && _.isArray(event.action)) {
                    _.forEach(event.action, function(action) {
                        instance.addEvent(pi, { 'type': event.type, 'action': [action] });
                    })
                } else if (event.action && _.isObject(event.action)) {
                    instance.addEvent(pi, { 'type': event.type, 'action': [event.action] });
                }
            })
        } else if (_.isObject(events)) {
            if (events.action && _.isArray(events.action)) {
                _.forEach(events.action, function(action) {
                    var eventObj = { 'type': events.type, 'action': [action] };
                    if (!_.isUndefined(events.type)) {
                        eventObj.type = events.type;
                    }
                    instance.addEvent(pi, eventObj);
                })
            } else if (events.action && _.isObject(events.action)) {
                var eventObj = { 'type': events.type, 'action': [events.action] };
                if (!_.isUndefined(events.type)) {
                    eventObj.type = events.type;
                }
                instance.addEvent(pi, eventObj);
            }
        }
    },
    migrateEvents: function(events, pi) {
        var instance = this;
        if (_.isArray(events)) {
            _.forEach(events, function(event) {
                if (event.action && _.isArray(event.action)) {
                    _.forEach(event.action, function(action) {
                        instance.addEvent(pi, { 'type': event.type, 'action': [action] });
                    })
                } else if (event.action && _.isObject(event.action)) {
                    instance.addEvent(pi, { 'type': event.type, 'action': [event.action] });
                }
            })
        } else if (_.isObject(events)) {
            if (events.action && _.isArray(events.action)) {
                _.forEach(events.action, function(action) {
                    instance.addEvent(pi, { 'type': events.type, 'action': [action] });
                })
            } else if (events.action && _.isObject(events.action)) {
                instance.addEvent(pi, { 'type': events.type, 'action': [events.action] });
            }
        }
    },
    addEvent: function(pi, event) {
        if (_.isUndefined(pi.event)) pi.event = [];
        pi.event.push(event);
    }
}))

'use strict';

EkstepEditor.migration.settagmigration_task = new(Class.extend({
    init: function() {
        console.log('set tag migration-task initialized');
    },
    migrate: function(contentbody) {
        _.forEach(contentbody.theme.stage, function(stage, index) {
            //if stage has set tag, throw fatal error.                       
            if (_.has(stage, 'set')) EkstepEditor.migration.migrationErrors.push('Content has set tag on stage: '+ stage.id);
        });
    }
}));

EkstepEditor.IDispatcher = Class.extend({
    init: function() {
        this.initDispatcher();
    },
    initDispatcher: function() {throw 'Subclass should implement initDispatcher'},
    dispatch: function(event) {throw 'Subclass should implement dispatch'}
});
EkstepEditor.consoleDispatcher = new(EkstepEditor.IDispatcher.extend({
    type: "consoleDispatcher",
    initDispatcher: function() {},
    dispatch: function(event) {
        console.log(event);
    }
}));

EkstepEditor.localDispatcher = new(EkstepEditor.IDispatcher.extend({
    type: "localDispatcher",
    initDispatcher: function() {},
    http: angular.injector(["ng"]).get("$http"),
    dispatch: function(event) {        
        this.http.post('telemetry', event, function() {});
    }
}));

EkstepEditor.piwikDispatcher = new(EkstepEditor.IDispatcher.extend({
    type: "piwikDispatcher",
    piwikEndPoint: EkstepEditor.config.baseURL + "/piwik/piwik.php",
    idsite: 1,
    initDispatcher: function() {},
    dispatch: function(event) {
        if (!event) return;

        try {
            event = (typeof event === "string") ? event : JSON.stringify(event);
            EkstepEditorAPI.jQuery.post(this.piwikEndPoint + '?idsite=' + this.idsite + '&url=' + EkstepEditor.config.absURL+ location.pathname + '&e_c=ContentEditor&e_a=' + event + '&rec=1', function() {
                    //console.log('piwik event dispatched');
                })
                .fail(function() {
                    console.log("error: while piwik dispatch");
                });
        } catch (e) {
            console.log('error: piwik event cannot be stringify', e);
        }
    }
}));

/**
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */
'use strict';

angular.module('editorApp', ['ngDialog', 'oc.lazyLoad', 'Scope.safeApply']).config(['$locationProvider', '$httpProvider', function($locationProvider, $httpProvider) {
    $locationProvider.html5Mode({
        enabled: true,
        requireBase: false
    });
    $httpProvider.interceptors.push('apiTimeStamp');
}]);
angular.module('editorApp').controller('MainCtrl', ['$scope', '$timeout', '$http', '$location', '$q', '$window', '$document',
    function($scope, $timeout, $http, $location, $q, $window, $document) {

        // Declare global variables
        $scope.showAppLoadScreen = true;
        $scope.contentLoadedFlag = false;
        $scope.showGenieControls = false;
        $scope.developerMode = $location.search().developerMode;
        $scope.appLoadMessage = [
            { 'id': 1, 'message': 'Getting things ready for you', 'status': false }
        ];
        $scope.migrationFlag = false;
        $scope.saveBtnEnabled = true;
        $scope.model = {
            teacherInstructions: undefined
        }
        $scope.migration = {
            showMigrationError: false,
            showPostMigrationMsg: false,
            showMigrationSuccess: false
        }

        $scope.onLoadCustomMessage = {
            show: false,
            text: undefined
        }
        $scope.cancelLink = (($window.context && $window.context.cancelLink) ? $window.context.cancelLink : "");
        $scope.reportIssueLink = (($window.context && $window.context.reportIssueLink) ? $window.context.reportIssueLink : "");

        $scope.context = $window.context;
        $scope.contentId = $location.search().contentId;
        if (_.isUndefined($scope.contentId)) {
            $scope.contentId = (($window.context && $window.context.content_id) ? $window.context.content_id : undefined)
        }

        $scope.contentDetails = {
            contentTitle: "Untitled Content",
            contentImage: "/images/com_ekcontent/default-images/default-content.png",
            contentConcepts: "No concepts selected",
            contentType: ""
        };
        $scope.userDetails = !_.isUndefined(window.context) ? window.context.user : undefined;
        $scope.showInstructions = true;
        $scope.stageAttachments = {};

        // TODO: Figure out what the below code does
        EkstepEditorAPI.jQuery('.browse.item.at').popup({ on: 'click', setFluidWidth: false, position: 'bottom right' });

        // Functions
        $scope.closeLoadScreen = function(flag) {
            $scope.contentLoadedFlag = true;
            if (!$scope.migrationFlag || flag) {
                $scope.showAppLoadScreen = false;
            }
            $scope.$safeApply();
        }

        $scope.enableSave = function() {
            //$scope.saveBtnEnabled = true;
            //$scope.$safeApply();
        }

        $scope.previewContent = function(fromBeginning) {
            EkstepEditorAPI.getCanvas().deactivateAll().renderAll();
            var currentStage = _.isUndefined(fromBeginning) ? true : false;
            EkstepEditor.eventManager.dispatchEvent("atpreview:show", { contentBody: EkstepEditor.stageManager.toECML(), 'currentStage': currentStage });
            EkstepEditorAPI.dispatchEvent('config:settings:show', { id: $scope.currentStage.id });
        };

        $scope.saveContent = function() {
            if ($scope.saveBtnEnabled) {
                $scope.saveBtnEnabled = false;
                // TODO: Show saving dialog
                var contentBody = EkstepEditor.stageManager.toECML();
                $scope.patchContent({ stageIcons: JSON.stringify(EkstepEditor.stageManager.getStageIcons()) }, contentBody, function(err, res) {
                    if (res) $scope.saveNotification('success');
                    if (err) $scope.saveNotification('error'); 
                    $scope.saveBtnEnabled = true;                                                           
                });
            }
        }

        $scope.patchContent = function(metadata, body, cb) {
            if ($scope.migrationFlag) {
                if (!metadata) metadata = {};
                metadata.oldContentBody = $scope.oldContentBody;
                var migrationPopupCb = function() {
                    $scope.contentService.saveContent(EkstepEditorAPI.getContext('contentId'), metadata, body, cb);
                }
                $scope.showMigratedContentSaveDialog(migrationPopupCb);
            } else {
                $scope.contentService.saveContent(EkstepEditorAPI.getContext('contentId'), metadata, body, cb);
            }
        }

        $scope.toggleGenieControl = function() {
            if (!$scope.showGenieControls) {
                //Position the transparent image correctly on top of image
                var canvasOffset = EkstepEditorAPI.jQuery('#canvas').offset();
                setTimeout(function() {
                    EkstepEditorAPI.jQuery('#geniecontrols').offset({
                        "top": canvasOffset.top,
                        "left": canvasOffset.left,
                    });

                    EkstepEditorAPI.jQuery('#geniecontrols').css({
                        "display": 'block'
                    });
                }, 500);

            }
            $scope.showGenieControls = !$scope.showGenieControls;
        }

        $scope.convertToJSON = function(contentBody) {
            try {
                var x2js = new X2JS({ attributePrefix: 'none', enableToStringFunc: false });
                return x2js.xml_str2json(contentBody);
            } catch (e) {
                return;
            }
        }

        $scope.parseContentBody = function(contentBody) {
            try {
                contentBody = JSON.parse(contentBody);
            } catch (e) {
                contentBody = $scope.convertToJSON(contentBody);
            }
            if (_.isUndefined(contentBody) || _.isNull(contentBody)) {
                $scope.contentLoadedFlag = true;
                $scope.onLoadCustomMessage.show = true;
                $scope.onLoadCustomMessage.text = "Your content has errors! we are unable to read the content!";
                $scope.$safeApply();
                $scope.telemetryService.error({ "env": "content", "stage": "", "action": "show error and stop the application", "err": "Unable to read the content due to parse error", "type": "PORTAL", "data": "", "severity": "fatal" });
            };
            return contentBody;
        }

        $scope.onStageDragDrop = function(dragEl, dropEl) {
            EkstepEditor.stageManager.onStageDragDrop(EkstepEditor.jQuery('#' + dragEl).attr('data-id'), EkstepEditor.jQuery('#' + dropEl).attr('data-id'));
            EkstepEditorAPI.refreshStages();
        }

        $scope.editContentMeta = function() {
            var config = {
                template: 'editContentMetaDialog',
                controller: ['$scope', 'mainCtrlScope', function($scope, mainCtrlScope) {
                    $scope.routeToContentMeta = function(save) {
                        $scope.closeThisDialog();
                        mainCtrlScope.routeToContentMeta(save);
                    }
                }],
                resolve: {
                    mainCtrlScope: function() {
                        return $scope;
                    }
                },
                showClose: false
            };

            EkstepEditorAPI.getService('popup').open(config);
        }

        $scope.routeToContentMeta = function(save) {
            $scope.enableSave();
            if (save) {
                var contentBody = EkstepEditor.stageManager.toECML();
                $scope.patchContent({ stageIcons: JSON.stringify(EkstepEditor.stageManager.getStageIcons()) }, contentBody, function(err, res) {
                    if (res) {
                        $scope.saveNotification('success');
                        $window.location.assign(window.context.editMetaLink);                    
                    }
                    if (err) $scope.saveNotification('error');
                });
            } else {
                $window.location.assign(window.context.editMetaLink);
            }
        };

        $scope.saveNotification = function(message) {
            message = (message === 'success') ? 'saveSuccessMessage.html' : 'saveErrorMessage.html';
            var config = {
                template: message,
                showClose: false
            }
            $scope.popupService.open(config);
        };
        $scope.showMigratedContentSaveDialog = function(callback) {
            var instance = $scope;
            $scope.popupService.open({
                template: 'migratedContentSaveMsg.html',
                controller: ['$scope', function($scope) {
                    $scope.saveContent = function() {
                        instance.migrationFlag = false;
                        callback();
                    }

                    $scope.enableSaveBtn = function() {
                        instance.saveBtnEnabled = true;
                    }
                }],
                showClose: false,
                closeByDocument: false,
                closeByEscape: false
            });
        }

        /** 
         * Content Editor Initialization
         */
        // Set the context
        var context = {
            uid: $window.context.user.id,
            sid: $window.context.sid,
            contentId: $scope.contentId
        }
        // Config to override
        var config = {
            absURL: $location.protocol() + '://' + $location.host() + ':' + $location.port() // Required
        }

        /**
         * Load Content - Invoked once the content editor has loaded
         */
        $scope.loadContent = function() {
            EkstepEditorAPI.getService(ServiceConstants.CONTENT_SERVICE).getContent(EkstepEditorAPI.getContext('contentId'), function(err, content) {
                if (err) {
                    $scope.contentLoadedFlag = true;
                    $scope.onLoadCustomMessage.show = true;
                    $scope.onLoadCustomMessage.text = ":( Unable to fetch the content! Please try again later!";
                    $scope.telemetryService.error({ "env": "content", "stage": "", "action": "show error and stop the application", "err": "Unable to fetch content from remote", "type": "API", "data": err, "severity": "fatal" });
                }
                if (!(content && content.body) && !err) {
                    EkstepEditor.stageManager.onContentLoad((new Date()).getTime());
                    $scope.closeLoadScreen(true);
                } else if (content && content.body) {
                    $scope.oldContentBody = angular.copy(content.body);
                    var parsedBody = $scope.parseContentBody(content.body);
                    if (parsedBody) EkstepEditorAPI.dispatchEvent("content:migration:start", { body: parsedBody, stageIcons: content.stageIcons });
                }
                if (content) {
                    var concepts = "";
                    if (!_.isUndefined(content.concepts)) {
                        concepts = _.size(content.concepts) <= 1 ? content.concepts[0].name : content.concepts[0].name + ' & ' + (_.size(content.concepts) - 1) + ' more';
                    }
                    $scope.contentDetails = {
                        contentTitle: content.name,
                        contentImage: content.appIcon,
                        contentType: '| ' + content.contentType,
                        contentConcepts: concepts
                    };
                    $scope.setTitleBarText($scope.contentDetails.contentTitle);
                }
            });
        }
        /**
         * Initialize the ekstep editor
         * @param  {object} context The context for the editor to load
         * @param  {object} config The config for the editor to override/set
         * @param  {function} $scope Scope of the controller
         * @param  {function} callback Function to be invoked once the editor is loaded
         */
        EkstepEditor.init(context, config, $scope, $document, function() {
            var obj = _.find($scope.appLoadMessage, { 'id': 1 });
            if (_.isObject(obj)) {
                obj.message = "Getting things ready for you";
                obj.status = true;
            }
            $scope.contentService = EkstepEditorAPI.getService(ServiceConstants.CONTENT_SERVICE);
            $scope.popupService = EkstepEditorAPI.getService(ServiceConstants.POPUP_SERVICE);
            $scope.telemetryService = EkstepEditorAPI.getService(ServiceConstants.TELEMETRY_SERVICE);
            $scope.menus = EkstepEditor.toolbarManager.menuItems;
            $scope.contextMenus = EkstepEditor.toolbarManager.contextMenuItems;
            $scope.stages = EkstepEditorAPI.getAllStages();
            $scope.currentStage = EkstepEditorAPI.getCurrentStage();
            $scope.configMenus = $scope.configMenus || [];
            _.forEach(EkstepEditor.toolbarManager.configMenuItems,function (menu) {
                $scope.configMenus.push(menu);
            });

            $scope.loadContent();
            /* KeyDown event to show ECML */
            $document.on("keydown", function(event) {
                if ((event.metaKey || event.ctrlKey) && event.shiftKey && event.keyCode == 69) { /*ctrl+shift+e or command+shift+e*/
                    event.preventDefault();
                    EkstepEditorAPI.dispatchEvent("org.ekstep.viewecml:show", {});
                }
            });
        });

        $scope.fireEvent = function(event) {
            if (event) EkstepEditorAPI.dispatchEvent(event.id, event.data);
        };

        $scope.setTitleBarText = function(text) {
            if (text) document.title = text;
        };

        $scope.fireToolbarTelemetry = function(menu, menuType) {
            $scope.telemetryService.interact({ "type": "click", "subtype": "menu", "target": menuType, "pluginid": '', 'pluginver': '', "objectid": menu.id, "stage": EkstepEditor.stageManager.currentStage.id });
        }

        $scope.fireSidebarTelemetry = function(menu, menuType) {
            var pluginId = "", pluginVer = "", objectId = "";
            var pluginObject = EkstepEditorAPI.getCurrentObject() || EkstepEditorAPI.getCurrentStage();
            if(pluginObject) {
                pluginId = pluginObject.manifest.id;
                pluginVer = pluginObject.manifest.ver;
                objectId = pluginObject.id;
            }
            $scope.telemetryService.interact({ "type": "modify", "subtype": "sidebar", "target": menuType, "pluginid": pluginId, 'pluginver': pluginVer, "objectid": objectId, "stage": EkstepEditor.stageManager.currentStage.id });
        }
    }
]);

EkstepEditor.jQuery(document).ready(function() {
    var newheight = $(window).innerHeight() - 114;  
    EkstepEditor.jQuery('.scrollable-slides').css("height",newheight + "px");  
});

angular.module('editorApp').controller('popupController', ['ngDialog', '$ocLazyLoad', function(ngDialog, $ocLazyLoad) {
    function loadNgModules(templatePath, controllerPath) {
        $ocLazyLoad.load([
            { type: 'html', path: templatePath },
            { type: 'js', path: controllerPath }
        ]);
    };

    function openModal(config, callback) {
        if (config && callback) config.preCloseCallback = callback;
        if (config) ngDialog.open(config);
    };

    EkstepEditorAPI.getService('popup').initService(loadNgModules, openModal);

}]);

angular.module('editorApp').directive('lvlDraggable', ['$rootScope', function ($rootScope) {
    return {
        restrict: 'A',
        link: function (scope, el, attrs, controller) {
            angular.element(el).attr("draggable", "true");

            var id = angular.element(el).attr("id");

            if (!id) {
                id = window.UUID();
                angular.element(el).attr("id", id);
            }
            
            el.bind("dragstart", function (e) {
                e.originalEvent.dataTransfer.setData('text', id);                
                $rootScope.$emit("LVL-DRAG-START");
            });

            el.bind("dragend", function (e) {
                $rootScope.$emit("LVL-DRAG-END");
            });
        }
    };
}]);
angular.module('editorApp').directive('lvlDropTarget', ['$rootScope', function ($rootScope) {
    return {
        restrict: 'A',
        scope: {
            onDrop: '&'
        },
        link: function (scope, el, attrs, controller) {
            var id = angular.element(el).attr("id");
            if (!id) {
                id = window.UUID();
                angular.element(el).attr("id", id);
            }

            el.bind("dragover", function (e) {
                if (e.preventDefault) {
                    e.preventDefault(); // Necessary. Allows us to drop.
                }

                e.originalEvent.dataTransfer.dropEffect = 'move';  // See the section on the DataTransfer object.
                return false;
            });

            el.bind("dragenter", function (e) {
                // this / e.target is the current hover target.
                angular.element(e.target).addClass('lvl-over');
            });

            el.bind("dragleave", function (e) {
                angular.element(e.target).removeClass('lvl-over');  // this / e.target is previous target element.
            });

            el.bind("drop", function (e) {
                if (e.preventDefault) {
                    e.preventDefault(); // Necessary. Allows us to drop.
                }

                if (e.stopPropagation) {
                    e.stopPropagation(); // Necessary. Allows us to drop.
                }
                var data = e.originalEvent.dataTransfer.getData("text");
                var dest = document.getElementById(id);
                var src = document.getElementById(data);

                scope.onDrop({dragEl: data, dropEl: id});
            });

            $rootScope.$on("LVL-DRAG-START", function () {
                var el = document.getElementById(id);
                angular.element(el).addClass("lvl-target");
            });

            $rootScope.$on("LVL-DRAG-END", function () {
                var el = document.getElementById(id);
                angular.element(el).removeClass("lvl-target");
                angular.element(el).removeClass("lvl-over");
            });
        }
    };
}]);
'use strict';

angular.module('editorApp').factory('apiTimeStamp', [function() {  
    var timeTaken = {
        request: function(config) {
            config.requestTimestamp = new Date().getTime();
            return config;
        },
        response: function(response) {
            response.config.responseTimestamp = new Date().getTime();
            return response;
        }
    };
    return timeTaken;
}]);
EkstepEditor.iService = Class.extend({
    init: function(config) {
        this.initService(config);
    },
    initService: function(config) {},
    http: {
        $http: angular.injector(["ng", "editorApp"]).get("$http"),
        get: function(url, config, cb) {
            var instance = this;
            if (!config) config = {};
            return this.$http.get(url, config).then(function(res) {
                instance._dispatchTelemetry({url: url, method: "GET", request: "", res: res});
                cb(null, res) 
            }, function(res) {
                instance._dispatchTelemetry({url: url, method: "GET", request: "", res: res});                
                cb(res, null) 
            });
        },
        post: function(url, data, config, cb) {
            var instance = this;
            if (!config) config = {};
            return this.$http.post(url, data, config).then(function(res) { 
                instance._dispatchTelemetry({url: url, method: "POST", request: data, res: res});
                cb(null, res) 
            }, function(res) { 
                instance._dispatchTelemetry({url: url, method: "POST", request: data, res: res});
                cb(res, null) 
            });
        },
        patch: function(url, data, config, cb) {
            var instance = this;
            if (!config) config = {};
            return this.$http.patch(url, data, config).then(function(res) {
                instance._dispatchTelemetry({url: url, method: "PATCH", request: data, res: res}); 
                cb(null, res) 
            }, function(res) { 
                instance._dispatchTelemetry({url: url, method: "PATCH", request: data, res: res}); 
                cb(res, null) 
            });
        },
        _dispatchTelemetry: function (data) {
            var responseTime = (data.res.config.responseTimestamp - data.res.config.requestTimestamp);
            EkstepEditor.telemetryService.apiCall({ "path": data.url, "method": data.method, "request": data.request, "response": "","responseTime": responseTime, "status": data.res.status, "uip": "" }); 
        }
    }
});
/**
 * Content service helps to retrieve/save the content, content meta details by making call to learning API.
 * It also helps to download the content. 
 * 
 * @class EkstepEditor.contentService
 * @author Sunil A S <sunils@ilimi.in>
 */
EkstepEditor.contentService = new(EkstepEditor.iService.extend({
    serviceURL: EkstepEditor.config.baseURL + EkstepEditorAPI.getConfig('apislug') + '/learning/',
    content: {},
    initService: function() {},
    /**
    *
    * content meta data fields
    *
    * @memberof EkstepEditor.contentService
    */
    contentFields: "body,editorState,stageIcons,templateId,languageCode,template,gradeLevel,status,concepts,versionKey,name,appIcon,contentType,owner,domain,code,visibility,portalOwner,description,language,mediaType,mimeType,osId,languageCode,createdOn,lastUpdatedOn",
    requestHeaders: {
        "headers": {
            "content-type": "application/json",
            "user-id": "content-editor"
        }
    },
    /**
    * 
    * sets content meta for the given content id
    * @param id {string}
    * @param contentMeta {object} content meta object
    * @private
    * @memberof EkstepEditor.contentService
    */
    _setContentMeta: function(id, contentMeta) {
        if (id && contentMeta) {
            var meta = {};
            for(k in contentMeta) {
                if(k != 'body' && k != 'stageIcons') {
                    meta[k] = contentMeta[k];
                }
            }
            this.content[id] = meta;
        }
    },
    /**
    *
    * returns content meta details
    * @param id {string} content id
    * @returns {object} if id is "undefined" returns empty object
    *
    * @memberof EkstepEditor.contentService
    */
    getContentMeta: function(id) {
        return this.content[id] || {};
    },
    /**
    *
    * saves content body by making call to learing API 
    * @param contentId {string} content id
    * @param metadata {object} meta data object
    * @param body {object} ECML JSON object of content
    * @param callback {function} callback function 
    *
    * @memberof EkstepEditor.contentService
    */
    saveContent: function(contentId, metadata, body, callback) {
        this._saveContent(contentId, metadata, body, callback);
    },
    /**
    *
    * saves content body by making call to learing API 
    * @param contentId {string} content id
    * @param metadata {object} meta data object
    * @param body {object} ECML JSON object of content
    * @param callback {function} callback function 
    * @private
    * @memberof EkstepEditor.contentService
    *
    */
    _saveContent: function(contentId, metadata, body, callback) {

        var instance = this;
        var versionKey = instance.content[contentId] && instance.content[contentId].versionKey;

        if (contentId && versionKey) {
            var update = false;
            var content = {
                versionKey: versionKey
            }
            if (metadata) {
                update = true;
                for (k in metadata) {
                    content[k] = metadata[k];
                }
            }
            if (body) {
                content['body'] = JSON.stringify(body);
                update = true;
            }
            if (update) {
                var headers = { "headers": { "content-type": "application/json", "user-id": "ATTool" } }
                var requestObj = { request: { content: content } };
                instance.http.patch(this.serviceURL + 'v2/content/' + contentId, requestObj, headers, function(err, res) {
                    if (res) {
                        instance.content[contentId].versionKey = res.data.result.versionKey;
                    }
                    callback(err, res);
                });
            } else {
                callback('Nothing to save');
            }
        } else {
            callback('Cannot find content id or version key to update content');
        }
    },
    /**
    *
    *
    * retrieves the content and content meta details
    * @param contentId {string} content id
    * @param callback {function} callback function
    *
    * @memberof EkstepEditor.contentService
    */
    getContent: function(contentId, callback) {
        var instance = this;
        if (contentId) {
            var metaDataFields = "?fields=" + instance.contentFields;
            instance.http.get(this.serviceURL + 'v2/content/' + contentId + metaDataFields, {}, function(err, res) {
                if (err) callback(err, undefined);
                if (!err && res.data && res.data.result && res.data.result.content) {
                    instance._setContentMeta(contentId, res.data.result.content);
                    callback(err, res.data.result.content);
                } else {
                    callback(new Error('no content found!'), undefined)
                }

            });
        } else {
            callback('Content id is required to get content from platform', undefined);
        }
    },
    /**
     * retrieves template data of selected templateid
     * @param templateId {string} template id
     * @param callback {function} callback function
     * @memberof EkstepEditor.contentService
     */
    getTemplateData: function(templateId, callback){
        var instance = this;
        var templateMetaFields = "?taxonomyId=literacy_v2&fields=body,editorState,templateId,languageCode";
        instance.http.get(this.serviceURL + 'v2/content/' + templateId + templateMetaFields, this.requestHeaders, function(err, res) {
            callback(err, res)
        });
    },
    /**
    *
    *
    * retrieves downloadable URL link to content
    * @param contentId {string} content id
    * @param fileName {string} "name" parameter of meta data object
    * @param callback {function} callback function
    *
    * @memberof EkstepEditor.contentService
    */
    downloadContent: function(contentId, fileName, callback) {
        var data = { "request": { "content_identifiers": [contentId], "file_name": fileName } };
        this.postFromService(this.serviceURL + 'v2/content/bundle', data, this.requestHeaders, callback);
    },
    postFromService: function(url, data, headers, callback) {
        var instance = this;
        instance.http.post(url, JSON.stringify(data), headers, function(err, res) {
            callback(err, res)
        });
    }
}));

/**
 * 
 * Popup service helps to show interactive popup modal/dialog window from plugin
 * 
 * @class EkstepEditor.popupService
 * @author Sunil A S <sunils@ilimi.in>
 */
EkstepEditor.popupService = new(EkstepEditor.iService.extend({
    loadModules: undefined,
    openModal: undefined,
    initService: function(loadModuleFn, openModalFn) {
        this.loadModules = loadModuleFn;
        this.openModal = openModalFn;
    },
    /**
    *
    * loads HTML template and angular module 
    * @param templatePath {string} path to HTML template
    * @param controllerPath {string} path to angular module
    * @memberof EkstepEditor.popupService
    */
    loadNgModules: function(templatePath, controllerPath) {
        this.loadModules && this.loadModules(templatePath, controllerPath);
    },
    /**
    *
    * opens popup modal/dialog window
    * @param config {object} config object refers to ngDialog open method parameter. please refer [ngDialog docs]{@link https://github.com/likeastore/ngDialog#openoptions}
    * @param callback {function} pre close Callback 
    * @memberof EkstepEditor.popupService
    */
    open: function(config, callback){
        if(this.openModal) {
            this.openModal(config, callback);
            EkstepEditor.telemetryService.interact({ "type": "click", "subtype": "open", "target": "popup", "pluginid": "", "pluginver": '', "objectid": "", "stage": EkstepEditorAPI.getCurrentStage().id });
        }
    }
}));

/**
 *
 * Telemetry service helps to log telemetry events. Telemetry service generates below listed events
 * and logs to registered dispatchers.
 * <ol>
 *  <li>CE_START
 *  <li>CE_API_CALL
 *  <li>CE_INTERACT
 *  <li>CE_PLUGIN_LIFECYCLE
 *  <li>CE_ERROR
 *  <li>CE_END
 * </ol>
 *
 * @class EkstepEditor.telemetryService
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */
EkstepEditor.telemetryService = new(EkstepEditor.iService.extend({
    context: {},
    dispatchers: [],
    initialized: true,
    start_event: undefined,
    startEventData: undefined,
    /**
    * 
    * Initialize the service with context and dispatcher.     
    * @param context {object} context object can have uid, sid, context_id. 
    * context should have content id, otherwise telemetry service cannot be initialized.
    * @param dispatcher {string} There are 3 types of dispatcher available, anyone of dispatcher 
    * is allowed and same dispatcher is used throughout the editor session. 
    * <ol>
    *   <li>Local dispatcher - dev environment only, logs to file (telemetry.log) - value: "local"
    *   <li>piwik dispatcher - logs to piwik endpoint - value: "piwik"
    *   <li>console dispatcher - logs to client console, default dispatcher - value: undefined
    * </ol>
    * 
    * @memberof EkstepEditor.telemetryService
    *
    */
    initialize: function(context, dispatcher) {
        var instance = this;
        this.context = context;
        if(_.isUndefined(this.context.cdata)) {
            this.context.cdata = [];
        }
        if(_.isUndefined(this.context.uid) || _.isUndefined(this.context.sid) || _.isUndefined(this.context.content_id)) {
            console.error('Unable to instantiate telemetry service');
            this.initialized = false;
        }
        if (!_.isUndefined(dispatcher)) this.addDispatcher(dispatcher);

        window.addEventListener('beforeunload', function() {
            instance.end();
        }); 

        this.startEventData = { defaultPlugins: Object.keys(EkstepEditor.pluginManager.plugins), loadtimes: {}, client: {} };
    },
    /**
    *
    * to populate data for start event (CE_START)  
    * @param autoplublish {boolean} if "true" logs the events through dispatcher. 
    * @returns {object} returns method chain. 
    * <ol>
    *   <li> <pre>getData()</pre>: return start event data
    *   <li> <pre>append(param, dataObj)</pre>: appends only "loadtimes" param of CE_START with dataObj(type: object). 
    * <ol> 
    * @memberof EkstepEditor.telemetryService
    *
    */
    startEvent: function(autopublish) {
        var instance = this;
        return {
            getData: function() {
                return instance.startEventData;
            },
            append: function(param, dataObj) {
                _.forIn(dataObj, function(value, key) {
                    instance.startEventData[param][key] = value;
                });
                if (autopublish) instance.start();
            }
        }
    },
    /**
    *
    * returns dispatcher instance
    * @param dispatcherId {string}     
    * <ol>
    *   <li>Local dispatcher: value: "local"
    *   <li>piwik dispatcher: value: "piwik"
    *   <li>(default) console dispatcher: value: undefined 
    * </ol>
    * @returns dispatcher {object}
    * @memberof EkstepEditor.telemetryService
    *
    */
    getDispatcher: function(dispatcherId) {
        switch(dispatcherId) {
            case "local":
                return EkstepEditor.localDispatcher;
                break;
            case "piwik":
                return EkstepEditor.piwikDispatcher;
                break;
            default:
                return EkstepEditor.consoleDispatcher;
        }
    },
    /**
    * 
    * To add a dispatcher to the dispatcher registry
    * @param dispatcherId {string}
    * <ol>
    *   <li>Local dispatcher: value: "local"
    *   <li>piwik dispatcher: value: "piwik"
    *   <li>(default) console dispatcher: value: undefined 
    * </ol>
    * @memberof EkstepEditor.telemetryService
    *
    */
    addDispatcher: function(dispatcherId) {
        var dispatcher = this.getDispatcher(dispatcherId);
        var dispatcherExist = _.find(this.dispatchers, function(obj){
           return  obj.type === dispatcher.type;
        });
        if(!dispatcherExist) this.dispatchers.push(dispatcher);
    },
    /**
     *
     * dispatch event to all registered dipatchers
     * @private
     * @param message {event} structured event
     * @memberof EkstepEditor.telemetryService
     *
     */
    _dispatch: function(message) {
        if (this.initialized) {
            _.forEach(this.dispatchers, function(dispatcher) {
                dispatcher.dispatch(message);
            })
        }
    },
    /**
    *
    * returns structured telemetry event for the given data
    * @param eventId {string} 
    * <ol>
    *  <li>CE_START
    *  <li>CE_API_CALL
    *  <li>CE_INTERACT
    *  <li>CE_PLUGIN_LIFECYCLE
    *  <li>CE_ERROR
    *  <li>CE_END
    * </ol>
    * @param data {object} telemetry data object specified for each telemetry event.
    * @memberof EkstepEditor.telemetryService
    *
    */
    getEvent: function(eventId, data) {
        return {
            "eid": eventId,
            "ets": (new Date()).getTime(), 
            "ver": "1.0",
            "pdata": {"id": "ATTool","pid": "ContentEditor","ver": "2.0"},
            "cdata": this.context.cdata, //TODO: No correlation data as of now. Needs to be sent by portal in context
            "uid": this.context.uid, // uuid of the requester
            "context": {"sid": this.context.sid,"content_id": this.context.content_id},
            "rid": "", // Leave blank.
            "edata": { "eks": data},
            "tags":[]
        }
    },
    /**
    *
    * validates telemetry data with mandatory fields
    * @param data {object} telemetry data
    * @param mandatoryFields {array} required fields for the specific telemetry to validate
    * @memberof EkstepEditor.telemetryService
    *
    */
    hasRequiredData: function(data, mandatoryFields) {
        var isValid = true;
        _.forEach(mandatoryFields, function(key) {
            if (!_.has(data, key)) isValid = false;
        });
        return isValid;
    },
    interactRequiredFields: ["type", "subtype", "target", "pluginid", "pluginver", "objectid", "stage"],
    lifecycleRequiredFields: ["type", "pluginid", "pluginver", "objectid", "stage"],
    errorRequiredFields: ["env", "stage", "action", "err", "type", "data", "severity"],
    apiCallRequiredFields: ["path", "method", "request", "response","responseTime", "status", "uip"],
    /**
    *
    * dispatches interact event (CE_INTERACT)
    * @param data {object} interact event data
    * @memberof EkstepEditor.telemetryService
    *
    */
    interact: function(data) {
        if(!this.hasRequiredData(data, this.interactRequiredFields)) {
            console.error('Invalid interact data');    
        }
        this._dispatch(this.getEvent('CE_INTERACT', data))
    },
    /**
    *
    * dispatches end event (CE_END)
    * @memberof EkstepEditor.telemetryService
    *
    */
    end: function() {
        var endEvent = this.getEvent('CE_END', {});
        endEvent.edata.eks.duration = (new Date()).getTime() - this.start_event.ets;
        this._dispatch(endEvent);
    },
    /**
    *
    * dispatches plugin lifecycle event (CE_PLUGIN_LIFECYCLE)
    * @param data {object} plugin lifecycle event data
    * @memberof EkstepEditor.telemetryService
    *
    */
    pluginLifeCycle: function(data) {
        if(!this.hasRequiredData(data, this.lifecycleRequiredFields)) {
            console.error('Invalid plugin lifecycle event data');    
        }
        this._dispatch(this.getEvent('CE_PLUGIN_LIFECYCLE', data))
    },
    /**
    *
    * dispatches error event (CE_ERROR)
    * @param data {object} error event data
    * @memberof EkstepEditor.telemetryService
    *
    */
    error: function(data) {
        if(!this.hasRequiredData(data, this.errorRequiredFields)) {
            console.error('Invalid error data');
        }
        this._dispatch(this.getEvent('CE_ERROR', data))
    },
    /**
    *
    * dispatches start event (CE_START)
    * @memberof EkstepEditor.telemetryService
    *
    */
    start: function() {
        this.startEventData.client = this.detectClient();
        this.start_event = this.getEvent('CE_START', this.startEventData);
        this._dispatch(this.start_event);
    },
    /**
    *
    * dispatches api call event (CE_API_CALL)
    * @param data {object} api call event data
    * @memberof EkstepEditor.telemetryService
    *
    */
    apiCall: function(data) {
        if (!this.hasRequiredData(data, this.apiCallRequiredFields)) {
            console.error('Invalid api call data');
        }
        this._dispatch(this.getEvent('CE_API_CALL', data))
    },
    /**
    *
    * returns client machine info such as OS, browser, browser version
    * @memberof EkstepEditor.telemetryService
    *
    */
    detectClient: function() {        
        var nAgt = navigator.userAgent;
        var browserName = navigator.appName;
        var fullVersion = '' + parseFloat(navigator.appVersion);
        var nameOffset, verOffset, ix;

        // In Opera
        if ((verOffset = nAgt.indexOf("Opera")) != -1) {
            browserName = "opera";
            fullVersion = nAgt.substring(verOffset + 6);
            if ((verOffset = nAgt.indexOf("Version")) != -1)
                fullVersion = nAgt.substring(verOffset + 8);
        }
        // In MSIE
        else if ((verOffset = nAgt.indexOf("MSIE")) != -1) {
            browserName = "IE";
            fullVersion = nAgt.substring(verOffset + 5);
        }
        // In Chrome
        else if ((verOffset = nAgt.indexOf("Chrome")) != -1) {
            browserName = "chrome";
            fullVersion = nAgt.substring(verOffset + 7);
        }
        // In Safari
        else if ((verOffset = nAgt.indexOf("Safari")) != -1) {
            browserName = "safari";
            fullVersion = nAgt.substring(verOffset + 7);
            if ((verOffset = nAgt.indexOf("Version")) != -1)
                fullVersion = nAgt.substring(verOffset + 8);
        }
        // In Firefox
        else if ((verOffset = nAgt.indexOf("Firefox")) != -1) {
            browserName = "firefox";
            fullVersion = nAgt.substring(verOffset + 8);
        }
        
        // trim the fullVersion string at semicolon/space if present
        if ((ix = fullVersion.indexOf(";")) != -1)
            fullVersion = fullVersion.substring(0, ix);
        if ((ix = fullVersion.indexOf(" ")) != -1)
            fullVersion = fullVersion.substring(0, ix);

        return { browser: browserName, browserver: fullVersion, os: navigator.platform };
    }
}));

/**
 *
 * Assessment service helps to get questions(items)
 * @class EkstepEditor.assessmentService
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */
EkstepEditor.assessmentService = new(EkstepEditor.iService.extend({
    /** 
     * @member {string} learningURL
     * @memberof EkstepEditor.assessmentService
     */
    learningURL: EkstepEditor.config.baseURL + EkstepEditorAPI.getConfig('apislug') + '/learning/',
     /** 
     * @member {object} requestHeaders
     * @memberof EkstepEditor.assessmentService
     */
    requestHeaders: {
        "headers": {
            "content-type": "application/json",
            "user-id": "content-editor"
        }
    },
    /**
     * Get Questions from search API
     * @param  {object}   data     search filter data
     * @param  {Function} callback returns error and response as arguments
     * @memberof EkstepEditor.assessmentService
     */
    getQuestions: function(data, callback) {
        EkstepEditorAPI.getService('search').search(data, callback);
    },
    /**
     * Get selected Question(assessmentitem)
     * @param  {string}   itemId   selected question(assessmentitem) id
     * @param  {Function} callback returns error and response as arguments
     * @memberof EkstepEditor.assessmentService
     */
    getItem: function(itemId, callback) {
        this.getFromService(this.learningURL + 'v1/assessmentitem/' + itemId, this.requestHeaders, callback);
    },
    /**
     * Get template data of selected question from content service API
     * @param  {string}   templateId selected question(assessmentitem) template id
     * @param  {Function} callback   returns error and response as arguments
     * @memberof EkstepEditor.assessmentService
     */
    getTemplate: function(templateId, callback) {
        EkstepEditorAPI.getService('content').getTemplateData(templateId, callback);
    },
    /**
     * Utility function which is used to call http get request
     * @param  {string}   url      API url
     * @param  {object}   headers  API headers
     * @param  {Function} callback returns error and response as arguments
     * @memberof EkstepEditor.metaService
     */
    getFromService: function(url, headers, callback) {
        var instance = this;
        instance.http.get(url, headers, function(err, res) {
            callback(err, res);
        });
    }
}));

/**
 * Asset service provides access to the content API to save assets.
 * @class EkstepEditor.assetService
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */
EkstepEditor.assetService = new(EkstepEditor.iService.extend({
     /** 
     * @member {string} searchURL
     * @memberof EkstepEditor.assetService
     */
    learningURL: EkstepEditor.config.baseURL + EkstepEditorAPI.getConfig('apislug') + '/learning/',
    asset: {},
     /** 
     * @member {object} requestHeaders
     * @memberof EkstepEditor.assetService
     */
    requestHeaders: {
        "headers": {
            "content-type": "application/json",
            "user-id": "content-editor"
        }
    },
    initService: function() {},
    /**
     * Set asset object
     * @param {string} id        
     * @param {object} assetMeta 
     * @memberof EkstepEditor.assetService
     */
    setAssetMeta: function(id, assetMeta) {
        if (id) {
            this.asset[id] = _.isUndefined(this.asset[id]) ? {} : this.asset[id];
            this.asset[id].assetMeta = _.isUndefined(assetMeta) ? this.asset[id].assetMeta : assetMeta;
        }
    },
    /**
     * get asset object
     * @param  {string} id 
     * @memberof EkstepEditor.assetService
     */
    getAssetMeta: function(id) {
        return this.asset[id] || {};
    },
    /**
     * This method is used to save assets(audio & image)
     * @param  {string}   assetId
     * @param  {string}   content
     * @param  {Function} callback returns error and response as arguments
     * @memberof EkstepEditor.assetService
     */
    saveAsset: function(assetId, content, callback) {
        var instance = this;

        var requestObj = {
            request: {
                content: content
            }
        };
        if (assetId) {
            instance.http.patch(this.learningURL + 'v2/content/', requestObj, this.requestHeaders, function(err, res) {
                callback(err, res)
            });
        } else {
            instance.http.post(this.learningURL + 'v2/content', requestObj, this.requestHeaders, function(err, res) {
                callback(err, res)
            });
        }
    }
}));

/**
 *
 * 
 * @class EkstepEditor.metaService
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */
EkstepEditor.metaService = new(EkstepEditor.iService.extend({
    /** 
     * @member {string} learningURL
     * @memberof EkstepEditor.metaService
     */
    learningURL: EkstepEditor.config.baseURL + EkstepEditorAPI.getConfig('apislug') + '/learning/',
    /** 
     * @member {string} configURL
     * @memberof EkstepEditor.metaService
     */
    configURL: EkstepEditor.config.baseURL + '/api/config/',
    /** 
     * @member {object} requestHeaders
     * @memberof EkstepEditor.metaService
     */
    requestHeaders: {
        "headers": {
            "content-type": "application/json",
            "user-id": "content-editor"
        }
    },
    /**
     * 
     * @param  {string}   objectType  eg.AssessmentItem, Language etc.
     * @param  {Function} callback    returns error and response as arguments
     * @memberof EkstepEditor.metaService
     */
    getDefinitions: function(objectType, callback) {
        this.getFromService(this.learningURL + 'taxonomy/domain/definition/'+ objectType, this.requestHeaders, callback);
    },
    /**
     * 
     * @param  {string}   languageCode  eg. en, hi etc.
     * @param  {Function} callback      returns error and response as arguments
     * @memberof EkstepEditor.metaService
     */
    getResourceBundles: function(languageCode ,callback) {
        this.getFromService(this.configURL + 'v2/config/resourcebundles/'+ languageCode, this.requestHeaders, callback);
    },
    /**
     * Utility function which is used to call http get request
     * @param  {string}   url      API url
     * @param  {object}   headers  API headers
     * @param  {Function} callback returns error and response as arguments
     * @memberof EkstepEditor.metaService
     */
    getFromService: function(url, headers, callback) {
        var instance = this;
        instance.http.get(url, headers, function(err, res) {
            callback(err, res);
        });
    }
}));

/**
 * 
 * Language service helps to get languages and wordnet data.
 * @class EkstepEditor.languageService
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 * 
 */
EkstepEditor.languageService = new(EkstepEditor.iService.extend({
    /** 
     * @member {string} learningURL
     * @memberof EkstepEditor.languageService
     */
    learningURL: EkstepEditor.config.baseURL + '/api/learning/',
    /** 
     * @member {string} languageURL
     * @memberof EkstepEditor.languageService
     */
    languageURL: EkstepEditor.config.baseURL + '/api/language/',
    /** 
     * @member {object} requestHeaders
     * @memberof EkstepEditor.languageService
     */
    requestHeaders: {
        "headers": {
            "content-type": "application/json",
            "user-id": "content-editor"
        }
    },
    /** 
     * @member {object} wordHeaders
     * @memberof EkstepEditor.languageService
     */
    wordHeaders: {
        "headers": {
            "Content-Type": "application/json",
            "Authorization": "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiI5OGNlN2RmNmNkOTk0YWQ5YjZlYTRjNDJlNmVjYjY5MCJ9.rtr4188EwDYZywtP7S9uuv1LsivoucFxOvJFDCWvq0Y"
            }
    },
    /**
     * Get all list of languages
     * @param  {Function} callback returns error and response as arguments
     * @memberof EkstepEditor.languageService
     */
    getLanguages: function(callback) {
        this.getFromService(this.learningURL + 'v1/language', this.requestHeaders, callback);
    },
    /**
     * Get all list of vowel available in selected language
     * @param  {string}   language eg. en, hi etc.
     * @param  {Function} callback returns error and response as arguments
     * @memberof EkstepEditor.languageService
     */
    getVowel: function(language,callback) {
        this.getFromService(this.languageURL + 'v1/language/dictionary/varna/Vowel/list/' + language, this.requestHeaders, callback);
    },
    /**
     * Get all list of consonant available in selected language
     * @param  {string}   language eg. en, hi etc.
     * @param  {Function} callback returns error and response as arguments
     * @memberof EkstepEditor.languageService
     */
    getConsonant: function(language,callback) {
        this.getFromService(this.languageURL + 'v1/language/dictionary/varna/Consonant/list/' + language, this.requestHeaders, callback);
    },
    /**
     * Get all avalible words in given content
     * @param  {object}   data     request object contains filters, objectType, exists etc
     * @param  {Function} callback returns error and response as arguments
     * @memberof EkstepEditor.languageService
     */
    getWords: function(data, callback) {
        this.postFromService(this.languageURL + 'v2/language/search', data, this.wordHeaders, callback);
    },
    /**
     * Get types of word. eg. Nouns, verbs etc 
     * @param  {Function} callback returns error and response as arguments
     * @memberof EkstepEditor.languageService
     */
    getWordDefinition: function(callback){
        this.getFromService(this.learningURL + 'taxonomy/en/definition/Word', this.requestHeaders, callback);
    },
    /**
     * Get all avalible keywords in given content
     * @param  {object}   data     request object
     * @param  {Function} callback returns error and response as arguments
     * @memberof EkstepEditor.languageService
     */
    getKeyWords: function(data, callback) {
        this.postFromService(this.languageURL + 'v1/language/parser', data, this.requestHeaders, callback);
    },
    /**
     * Utility function which is used to call http get request
     * @param  {string}   url      API url
     * @param  {object}   headers  API headers
     * @param  {Function} callback returns error and response as arguments
     * @memberof EkstepEditor.languageService
     */
    getFromService: function(url, headers, callback) {
        var instance = this;
        instance.http.get(url, headers, function(err, res) {
            callback(err, res);
        });
    },
    /**
     * Utility function which is used to call http post request
     * @param  {string}   url      API url
     * @param  {object}   data     APT request data
     * @param  {object}   headers  API headers
     * @param  {Function} callback returns error and response as arguments
     * @memberof EkstepEditor.languageService
     */
    postFromService: function(url, data, headers, callback) {
        var instance = this;
        instance.http.post(url, JSON.stringify(data), headers, function(err, res) {
            callback(err, res)
        });
    }

}));

/**
 *
 * Search service provides capability to search content(activities, question etc.) from  composite search API.
 * @class EkstepEditor.searchService
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */
EkstepEditor.searchService = new(EkstepEditor.iService.extend({
    /** 
     * @member {string} searchURL
     * @memberof EkstepEditor.searchService
     */
    searchURL: EkstepEditor.config.baseURL + EkstepEditorAPI.getConfig('apislug') + '/search/',
    /** 
     * @member {object} requestHeaders
     * @memberof EkstepEditor.searchService
     */
    requestHeaders: {
        "headers": {
            "content-type": "application/json",
            "user-id": "content-editor"
        }
    },
    initService: function() {},
    /**
     * Search method helps to get the content from search API
     * @param  {object}   request  request object will take all request parameters of search API
     * @param  {Function} callback returns error and response as arguments
     * @memberof EkstepEditor.searchService
     */
    search: function(request, callback) {
        this.postFromService(this.searchURL + 'v2/search', request, this.requestHeaders, callback);
    },
    /**
     * Utility function which is used to call http post request
     * @param  {string}   url      API url
     * @param  {object}   data     APT request data
     * @param  {object}   headers  API headers
     * @param  {Function} callback returns error and response as arguments
     * @memberof EkstepEditor.searchService
     */
    postFromService: function(url, data, headers, callback) {
        var instance = this;
        instance.http.post(url, JSON.stringify(data), headers, function(err, res) {
            callback(err, res)
        });
    }
}));
